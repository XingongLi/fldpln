
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Flood inundation modeling and mapping using the FLDPLN model">
      
      
        <meta name="author" content="xingongli">
      
      
        <link rel="canonical" href="https://xingongli.github.io/fldpln/mapping/">
      
      
        <link rel="prev" href="../tile/">
      
      
        <link rel="next" href="../gauge/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>mapping module - fldpln</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:300,300i,400,400i,700,700i%7CRegular:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Google Sans";--md-code-font:"Regular"}</style>
      
    
    
      <link rel="stylesheet" href="../css/timeago.css">
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#mapping-module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="fldpln" class="md-header__button md-logo" aria-label="fldpln" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            fldpln
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              mapping module
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/xingongli/fldpln" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="fldpln" class="md-nav__button md-logo" aria-label="fldpln" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    fldpln
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/xingongli/fldpln" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Usage
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/xingongli/fldpln/issues" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Report Issues
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Examples
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/intro/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Intro
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fldpln/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    fldpln module
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../common/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    common module
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tile/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tile module
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    mapping module
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    mapping module
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping" class="md-nav__link">
    <span class="md-ellipsis">
      fldpln.mapping
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.CreateFolders" class="md-nav__link">
    <span class="md-ellipsis">
      CreateFolders()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.EstimateFspDofFromGauge" class="md-nav__link">
    <span class="md-ellipsis">
      EstimateFspDofFromGauge()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.EstimateFspDofFromGaugeBlob" class="md-nav__link">
    <span class="md-ellipsis">
      EstimateFspDofFromGaugeBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.GetTileTifs" class="md-nav__link">
    <span class="md-ellipsis">
      GetTileTifs()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpBetweenTwoGauges" class="md-nav__link">
    <span class="md-ellipsis">
      InterpBetweenTwoGauges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpDofWithGauges" class="md-nav__link">
    <span class="md-ellipsis">
      InterpDofWithGauges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpolateFspDofFromGauge" class="md-nav__link">
    <span class="md-ellipsis">
      InterpolateFspDofFromGauge()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTiles" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTiles()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesAsDag" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesAsDag()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesBlobAsDag" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesBlobAsDag()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapOneTile" class="md-nav__link">
    <span class="md-ellipsis">
      MapOneTile()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapOneTileBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MapOneTileBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifs" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifs()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifsUsingVirtualRaster" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifsUsingVirtualRaster()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.NearestPoint" class="md-nav__link">
    <span class="md-ellipsis">
      NearestPoint()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.NearestPointInPlace" class="md-nav__link">
    <span class="md-ellipsis">
      NearestPointInPlace()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGauges2Fsps" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGauges2Fsps()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGauges2FspsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGauges2FspsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGaugesToFsps" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGaugesToFsps()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGaugesToFspsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGaugesToFspsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.TileFspFppRelations2Array" class="md-nav__link">
    <span class="md-ellipsis">
      TileFspFppRelations2Array()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.Tiles2Map" class="md-nav__link">
    <span class="md-ellipsis">
      Tiles2Map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.Tiles2MapBlob" class="md-nav__link">
    <span class="md-ellipsis">
      Tiles2MapBlob()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../gauge/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gauge module
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping" class="md-nav__link">
    <span class="md-ellipsis">
      fldpln.mapping
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.CreateFolders" class="md-nav__link">
    <span class="md-ellipsis">
      CreateFolders()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.EstimateFspDofFromGauge" class="md-nav__link">
    <span class="md-ellipsis">
      EstimateFspDofFromGauge()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.EstimateFspDofFromGaugeBlob" class="md-nav__link">
    <span class="md-ellipsis">
      EstimateFspDofFromGaugeBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.GetTileTifs" class="md-nav__link">
    <span class="md-ellipsis">
      GetTileTifs()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpBetweenTwoGauges" class="md-nav__link">
    <span class="md-ellipsis">
      InterpBetweenTwoGauges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpDofWithGauges" class="md-nav__link">
    <span class="md-ellipsis">
      InterpDofWithGauges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.InterpolateFspDofFromGauge" class="md-nav__link">
    <span class="md-ellipsis">
      InterpolateFspDofFromGauge()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTiles" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTiles()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesAsDag" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesAsDag()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapFloodDepthWithTilesBlobAsDag" class="md-nav__link">
    <span class="md-ellipsis">
      MapFloodDepthWithTilesBlobAsDag()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapOneTile" class="md-nav__link">
    <span class="md-ellipsis">
      MapOneTile()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MapOneTileBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MapOneTileBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifs" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifs()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.MosaicGtifsUsingVirtualRaster" class="md-nav__link">
    <span class="md-ellipsis">
      MosaicGtifsUsingVirtualRaster()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.NearestPoint" class="md-nav__link">
    <span class="md-ellipsis">
      NearestPoint()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.NearestPointInPlace" class="md-nav__link">
    <span class="md-ellipsis">
      NearestPointInPlace()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGauges2Fsps" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGauges2Fsps()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGauges2FspsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGauges2FspsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGaugesToFsps" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGaugesToFsps()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.SnapGaugesToFspsBlob" class="md-nav__link">
    <span class="md-ellipsis">
      SnapGaugesToFspsBlob()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.TileFspFppRelations2Array" class="md-nav__link">
    <span class="md-ellipsis">
      TileFspFppRelations2Array()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.Tiles2Map" class="md-nav__link">
    <span class="md-ellipsis">
      Tiles2Map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fldpln.mapping.Tiles2MapBlob" class="md-nav__link">
    <span class="md-ellipsis">
      Tiles2MapBlob()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  

  
  


<h1 id="mapping-module">mapping module<a class="headerlink" href="#mapping-module" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="fldpln.mapping"></a>
    <div class="doc doc-contents first">

      <p>Module for mapping tile-based library.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.CreateFolders" class="doc doc-heading">
<code class="highlight language-python"><span class="n">CreateFolders</span><span class="p">(</span><span class="n">outFolder</span><span class="p">,</span> <span class="n">scratchFolderName</span><span class="o">=</span><span class="s1">&#39;scratch&#39;</span><span class="p">,</span> <span class="n">outMapFolderName</span><span class="o">=</span><span class="s1">&#39;maps&#39;</span><span class="p">,</span> <span class="n">removeExist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a href="#fldpln.mapping.CreateFolders" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create folders for storing temporary files and output maps.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>outFolder</code></td>
        <td><code>str</code></td>
        <td><p>output folder</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>scratchFolderName</code></td>
        <td><code>str</code></td>
        <td><p>name of the folder for storing temporary files</p></td>
        <td><code>&#39;scratch&#39;</code></td>
      </tr>
      <tr>
        <td><code>outMapFolderName</code></td>
        <td><code>str</code></td>
        <td><p>name of the folder for storing output maps, default is 'maps'</p></td>
        <td><code>&#39;maps&#39;</code></td>
      </tr>
      <tr>
        <td><code>removeExist</code></td>
        <td><code>str</code></td>
        <td><p>bool whether to remove existing folders, default is True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>      

        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">CreateFolders</span><span class="p">(</span><span class="n">outFolder</span><span class="p">,</span><span class="n">scratchFolderName</span><span class="o">=</span><span class="s1">&#39;scratch&#39;</span><span class="p">,</span><span class="n">outMapFolderName</span><span class="o">=</span><span class="s1">&#39;maps&#39;</span><span class="p">,</span><span class="n">removeExist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create folders for storing temporary files and output maps.</span>

<span class="sd">        Args:</span>
<span class="sd">            outFolder (str): output folder</span>
<span class="sd">            scratchFolderName (str): name of the folder for storing temporary files</span>
<span class="sd">            outMapFolderName (str): name of the folder for storing output maps, default is &#39;maps&#39;</span>
<span class="sd">            removeExist (str): bool whether to remove existing folders, default is True</span>
<span class="sd">        Return: </span>
<span class="sd">            tuple: folder for output maps, folder for temporary files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create output folder if it doesn&#39;t exist</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outFolder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># scratch folder</span>
    <span class="n">scratchFolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outFolder</span><span class="p">,</span> <span class="n">scratchFolderName</span><span class="p">)</span>
    <span class="c1"># map output folder</span>
    <span class="n">outMapFolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outFolder</span><span class="p">,</span> <span class="n">outMapFolderName</span><span class="p">)</span>

    <span class="c1"># Create the folders for storing temp and output files</span>
    <span class="k">if</span> <span class="n">removeExist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">scratchFolder</span><span class="p">):</span> <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">scratchFolder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">):</span> <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">scratchFolder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outMapFolder</span><span class="p">,</span><span class="n">scratchFolder</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.EstimateFspDofFromGauge" class="doc doc-heading">
<code class="highlight language-python"><span class="n">EstimateFspDofFromGauge</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gaugeFspDf</span><span class="p">,</span> <span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">,</span> <span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.EstimateFspDofFromGauge" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Estimate/interpolate FSP DOF (Depth of Flow, i.e., FSP stage) from observed gauge DOFs using 
distance-(horizontal) or elevation-based (vertical) linear interpolation.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are located</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugeFspDf</code></td>
        <td><code>data frame</code></td>
        <td><p>a data frame of gauge FSPs (i.e., FSPs to which gauges are snapped). It should have at least 4 columns ['stage_elevation','lib_name','FspX','FspY'].</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>minGaugeDof</code></td>
        <td><code>float</code></td>
        <td><p>min DOF a gauge should have, by default is 1 cm = 0.0328083989501312 foot</p></td>
        <td><code>0.0328084</code></td>
      </tr>
      <tr>
        <td><code>weightingType</code></td>
        <td><code>str</code></td>
        <td><p>'V' for vertical distance-based or 'H' for horizontal distance-based, default is 'V'</p></td>
        <td><code>&#39;V&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with interpolated FSP DOFs.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">EstimateFspDofFromGauge</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gaugeFspDf</span><span class="p">,</span><span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">,</span><span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Estimate/interpolate FSP DOF (Depth of Flow, i.e., FSP stage) from observed gauge DOFs using </span>
<span class="sd">        distance-(horizontal) or elevation-based (vertical) linear interpolation.</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are located</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gaugeFspDf (data frame): a data frame of gauge FSPs (i.e., FSPs to which gauges are snapped). It should have at least 4 columns [&#39;stage_elevation&#39;,&#39;lib_name&#39;,&#39;FspX&#39;,&#39;FspY&#39;].</span>
<span class="sd">            minGaugeDof (float): min DOF a gauge should have, by default is 1 cm = 0.0328083989501312 foot</span>
<span class="sd">            weightingType (str): &#39;V&#39; for vertical distance-based or &#39;H&#39; for horizontal distance-based, default is &#39;V&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with interpolated FSP DOFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># select the gauge FSPs in the library</span>
    <span class="n">gaugeFspDf</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;lib_name&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">libName</span><span class="p">]</span>

    <span class="c1"># read in FSP and stream order network files</span>
    <span class="n">fspFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspInfoFileName</span><span class="p">)</span>
    <span class="n">strOrdFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">strOrdNetFileName</span><span class="p">)</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fspFile</span><span class="p">)</span> 
    <span class="n">strOrdDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">strOrdFile</span><span class="p">)</span> 

    <span class="c1"># Get gauge stream order for interpolation by stream orders</span>
    <span class="n">gaugeFspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">gaugeFspDf</span><span class="p">,</span><span class="n">fspDf</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">])[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;stage_elevation&#39;</span><span class="p">]]</span>
    <span class="c1"># print(gaugeFspDf)</span>

    <span class="c1"># calculate gauge FSP&#39;s DOF</span>
    <span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;stage_elevation&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span>
    <span class="c1"># reset gauge FSP DOF, if it&#39;s &lt; 0 or nodata, to minGaugeDof</span>
    <span class="n">gaugeFspDf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minGaugeDof</span><span class="p">)</span><span class="o">|</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">minGaugeDof</span>
    <span class="c1"># print(gaugeFspDf)</span>

    <span class="c1"># create an empty DF to store interpolated FSP DOFs</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">])</span>
    <span class="c1"># interpolate DoF for each stream order from low to high (low order means high priority!)</span>
    <span class="c1"># get the stream orders with gauges on them</span>
    <span class="n">strOrds</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strOrds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No stream found for the gauges!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="nb">ord</span> <span class="ow">in</span> <span class="n">strOrds</span><span class="p">:</span>
        <span class="c1"># gauges on the stream order</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># create the upstream ending gauge assuming a level water elevation at the gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get upstream gauge&#39;s segment IDs</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">upSegId</span><span class="p">,</span> <span class="n">gElev</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">t</span> 
        <span class="c1"># get segment FSPs and find the level-off FSP</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">upSegId</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># tell pandas we want a copy to avoid &quot;SettingWithCopyWarning&quot;</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gElev</span><span class="o">+</span><span class="n">dof</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># check if the ending gauge is the gauge itself</span>
        <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
            <span class="c1"># the gauge is the ending gauge.</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">t</span>
        <span class="c1"># print(usEndGauge)</span>

        <span class="c1">#</span>
        <span class="c1"># create downstream ending gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get the downstream order and junction FSP&#39;s coordinates</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">strOrdDf</span><span class="p">[</span><span class="n">strOrdDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;DsStrOrd&#39;</span><span class="p">,</span><span class="s1">&#39;JunctionFspX&#39;</span><span class="p">,</span> <span class="s1">&#39;JunctionFspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dsStrOrd</span><span class="p">,</span><span class="n">fspx</span><span class="p">,</span><span class="n">fspy</span> <span class="o">=</span> <span class="n">t</span> 

        <span class="c1"># whether there is a junction/confluence gauge</span>
        <span class="k">if</span> <span class="n">dsStrOrd</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># there is a downstream order. see whether the junction&#39;s DOF has an interpolated DOF</span>
            <span class="n">juncDf</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspx</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspy</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">juncDf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Junction has DOF. Create downstream ending gauge with the junction FSP</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">juncDf</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">juncDf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># No downstream order or junction FSP</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dsStrOrd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">juncDf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Create downstream ending gauge with the last FSP in the segment</span>
            <span class="c1"># get the downstream and upstream segment IDs</span>
            <span class="n">dsSegId</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># get the first FSP on the downstream segment</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">dsSegId</span><span class="p">]</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>
            <span class="c1"># check if the ending gauge is the gauge itself</span>
            <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
                <span class="c1"># the gauge is the ending gauge.</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">dsEndGauge</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># print(dsEndGauge)</span>

        <span class="c1"># put all the gauges together</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(usEndGauge)</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(dsEndGauge)</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">usEndGauge</span><span class="p">])</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">dsEndGauge</span><span class="p">])</span>
        <span class="c1"># print(f&quot;Gauges with DOFs on stream order ({ord}): \n&quot;,gaugeOrd)</span>

        <span class="c1"># calculate the min and max downstream distance</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">maxDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># select the FSPs on the stream order</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspOrd</span><span class="p">[(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minDist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxDist</span><span class="p">)]</span>
        <span class="n">fx</span><span class="p">,</span> <span class="n">fe</span> <span class="o">=</span> <span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># prepare gauges</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span>
        <span class="n">gx</span><span class="p">,</span> <span class="n">ge</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># interpolate</span>
        <span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpDofWithGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span><span class="n">fe</span><span class="p">,</span><span class="n">gx</span><span class="p">,</span><span class="n">ge</span><span class="p">,</span><span class="n">gy</span><span class="p">,</span><span class="n">weightingType</span><span class="p">)</span>

        <span class="c1"># append the interpolated SFPs</span>
        <span class="c1"># fspDof = fspDof.append(fspOrd,ignore_index=True)</span>
        <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">fspDof</span><span class="p">,</span><span class="n">fspOrd</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># print(fspDof)</span>

    <span class="c1"># select columns</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
    <span class="c1"># fspDof = fspDof[[&#39;FspId&#39;,&#39;DsDist&#39;,&#39;FilledElev&#39;,&#39;Dof&#39;]] # keep more columns for checking the interpolation</span>
    <span class="c1"># print(fspDof)</span>

    <span class="c1"># return interpolated DOF for the FSPs</span>
    <span class="k">return</span> <span class="n">fspDof</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.EstimateFspDofFromGaugeBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">EstimateFspDofFromGaugeBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gaugeDf</span><span class="p">,</span> <span class="n">gaugeElevField</span><span class="p">,</span> <span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">)</span></code>


<a href="#fldpln.mapping.EstimateFspDofFromGaugeBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Estimate FSP Depth of Flow (DoF), i.e., FSP stage from gauges on Microsoft Planetary Computer using Azure Blob Storage.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a BlobServiceClient object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugeDf</code></td>
        <td><code>data frame</code></td>
        <td><p>a data frame of gauges. It should have at least 4 columns ['FspX','FspY','FspFilledElev','Dist']</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugeElevField</code></td>
        <td><code>str</code></td>
        <td><p>the field in gaugeDf that stores gauge's water surface elevation</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>minGaugeDof</code></td>
        <td><code>float</code></td>
        <td><p>min DOF a gauge should have, default is 1 cm = 0.0328083989501312 foot. Negative DOF may occur as incorrect gauge datum</p></td>
        <td><code>0.0328084</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with interpolated FSP DOFs.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">EstimateFspDofFromGaugeBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gaugeDf</span><span class="p">,</span><span class="n">gaugeElevField</span><span class="p">,</span><span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Estimate FSP Depth of Flow (DoF), i.e., FSP stage from gauges on Microsoft Planetary Computer using Azure Blob Storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a BlobServiceClient object</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gaugeDf (data frame): a data frame of gauges. It should have at least 4 columns [&#39;FspX&#39;,&#39;FspY&#39;,&#39;FspFilledElev&#39;,&#39;Dist&#39;]</span>
<span class="sd">            gaugeElevField (str): the field in gaugeDf that stores gauge&#39;s water surface elevation</span>
<span class="sd">            minGaugeDof (float): min DOF a gauge should have, default is 1 cm = 0.0328083989501312 foot. Negative DOF may occur as incorrect gauge datum</span>

<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with interpolated FSP DOFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate FSP DOF</span>
    <span class="n">gaugeDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaugeDf</span><span class="p">[</span><span class="n">gaugeElevField</span><span class="p">]</span> <span class="o">-</span> <span class="n">gaugeDf</span><span class="p">[</span><span class="s1">&#39;FspFilledElev&#39;</span><span class="p">]</span>
    <span class="c1"># reset DOF, if it&#39;s &lt; 0, to minGaugeDof</span>
    <span class="n">gaugeDf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gaugeDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minGaugeDof</span><span class="p">,[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">minGaugeDof</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">gaugeDf</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># read in FSP and stream order network files </span>
    <span class="c1">#</span>
    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>

    <span class="c1"># read fsp info csv files</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">fspInfoFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="c1"># read stream order text file</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">strOrdNetFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">strOrdDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="c1"># Get gauge stream order for interpolation by stream orders</span>
    <span class="n">gaugeDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">gaugeDf</span><span class="p">,</span><span class="n">fspDf</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">])[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">,</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>
    <span class="c1"># print(gaugeDf)</span>

    <span class="c1"># create an empty DF to store interpolated FSP DOFs</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">])</span>
    <span class="c1"># interpolate DoF for each stream order from low to high (low order means high priority!)</span>
    <span class="c1"># get the stream orders with gauges on them</span>
    <span class="n">strOrds</span> <span class="o">=</span> <span class="n">gaugeDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strOrds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No stream found for the gauges!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="nb">ord</span> <span class="ow">in</span> <span class="n">strOrds</span><span class="p">:</span>
        <span class="c1"># gauges on the stream order</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeDf</span><span class="p">[</span><span class="n">gaugeDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># create the upstream ending gauge assuming a level water elevation at the gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get upstream gauge&#39;s segment IDs</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">upSegId</span><span class="p">,</span> <span class="n">gElev</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">t</span> 
        <span class="c1"># get segment FSPs and find the level-off FSP</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">upSegId</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># tell pandas we want a copy to avoid &quot;SettingWithCopyWarning&quot;</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gElev</span><span class="o">+</span><span class="n">dof</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># check if the ending gauge is the gauge itself</span>
        <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
            <span class="c1"># the gauge is the ending gauge.</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">t</span>
        <span class="c1"># print(usEndGauge)</span>

        <span class="c1">#</span>
        <span class="c1"># create downstream ending gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get the downstream order and junction FSP&#39;s coordinates</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">strOrdDf</span><span class="p">[</span><span class="n">strOrdDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;DsStrOrd&#39;</span><span class="p">,</span><span class="s1">&#39;JunctionFspX&#39;</span><span class="p">,</span> <span class="s1">&#39;JunctionFspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dsStrOrd</span><span class="p">,</span><span class="n">fspx</span><span class="p">,</span><span class="n">fspy</span> <span class="o">=</span> <span class="n">t</span> 

        <span class="c1"># whether there is a junction/confluence gauge</span>
        <span class="k">if</span> <span class="n">dsStrOrd</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># there is a downstream order. see whether the junction&#39;s DOF has an interpolated DOF</span>
            <span class="n">juncDf</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspx</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspy</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">juncDf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Junction has DOF. Create downstream ending gauge with the junction FSP</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">juncDf</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">juncDf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># No downstream order or junction FSP</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dsStrOrd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">juncDf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Create downstream ending gauge with the last FSP in the segment</span>
            <span class="c1"># get the downstream and upstream segment IDs</span>
            <span class="n">dsSegId</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># get the first FSP on the downstream segment</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">dsSegId</span><span class="p">]</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]]</span>
            <span class="c1"># check if the ending gauge is the gauge itself</span>
            <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
                <span class="c1"># the gauge is the ending gauge.</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">dsEndGauge</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># print(dsEndGauge) </span>

        <span class="c1"># put all the gauges together</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(usEndGauge)</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(dsEndGauge)</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">usEndGauge</span><span class="p">])</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">dsEndGauge</span><span class="p">])</span>
        <span class="c1"># print(f&quot;Gauges with DOFs on stream order ({ord}): \n&quot;,gaugeOrd)</span>

        <span class="c1"># calculate the min and max downstream distance</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">maxDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># select the FSPs on the stream order</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]]</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspOrd</span><span class="p">[(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minDist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxDist</span><span class="p">)]</span>

        <span class="c1"># interpolate DOF for the FSPs with the gauges</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span> <span class="c1"># for using np.interp(), x must be ascending!</span>
        <span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">],</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">],</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="c1"># print(fspOrd)</span>

        <span class="c1"># append the interpolated SFPs</span>
        <span class="c1"># fspDof = fspDof.append(fspOrd,ignore_index=True)</span>
        <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">fspDof</span><span class="p">,</span><span class="n">fspOrd</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># print(fspDof)</span>

    <span class="c1"># select and rename columns</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
    <span class="c1"># print(fspDof)</span>

    <span class="c1"># return interpolated DOF for the FSPs</span>
    <span class="k">return</span> <span class="n">fspDof</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.GetTileTifs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">GetTileTifs</span><span class="p">(</span><span class="n">tifFiles</span><span class="p">)</span></code>


<a href="#fldpln.mapping.GetTileTifs" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Get tile Geotif files</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>tifFiles</code></td>
        <td><code>list</code></td>
        <td><p>a list of tile Geotif files</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>a list of tile Geotif files</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">GetTileTifs</span><span class="p">(</span><span class="n">tifFiles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get tile Geotif files</span>

<span class="sd">        Args:</span>
<span class="sd">            tifFiles (list): a list of tile Geotif files</span>

<span class="sd">        Return:</span>
<span class="sd">            list: a list of tile Geotif files</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tileTifs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tif</span> <span class="ow">in</span> <span class="n">tifFiles</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">tileTifs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tileTifs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.InterpBetweenTwoGauges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">InterpBetweenTwoGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fe</span><span class="p">,</span> <span class="n">gx1</span><span class="p">,</span> <span class="n">ge1</span><span class="p">,</span> <span class="n">gy1</span><span class="p">,</span> <span class="n">gx2</span><span class="p">,</span> <span class="n">ge2</span><span class="p">,</span> <span class="n">gy2</span><span class="p">,</span> <span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.InterpBetweenTwoGauges" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) based on FSP's elevation (fe) or distance (fx) between two gauges.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>fx</code></td>
        <td><code>float or vector of float</code></td>
        <td><p>FSP's distance from downstream outlet.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fe</code></td>
        <td><code>float or vector of float</code></td>
        <td><p>FSP's elevation. Can be a vector</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gx1</code></td>
        <td><code>float</code></td>
        <td><p>gauge1's distance from downstream outlet</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ge1</code></td>
        <td><code>float</code></td>
        <td><p>gauge1's elevation</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gy1</code></td>
        <td><code>float</code></td>
        <td><p>gauge1's DOF</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gx2</code></td>
        <td><code>float</code></td>
        <td><p>gauge2's distance from downstream outlet</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ge2</code></td>
        <td><code>float</code></td>
        <td><p>gauge2's elevation</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gy2</code></td>
        <td><code>float</code></td>
        <td><p>gauge2's DOF</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>weightingType</code></td>
        <td><code>str</code></td>
        <td><p>'V' for vertical distance-based or 'H' for horizontal distance-based, default is 'V'</p></td>
        <td><code>&#39;V&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>float or vector of float</code></td>
      <td><p>interpolated DOF at fx</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">InterpBetweenTwoGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fe</span><span class="p">,</span> <span class="n">gx1</span><span class="p">,</span> <span class="n">ge1</span><span class="p">,</span> <span class="n">gy1</span><span class="p">,</span> <span class="n">gx2</span><span class="p">,</span> <span class="n">ge2</span><span class="p">,</span> <span class="n">gy2</span><span class="p">,</span> <span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) based on FSP&#39;s elevation (fe) or distance (fx) between two gauges.</span>

<span class="sd">        Args:</span>
<span class="sd">            fx (float or vector of float): FSP&#39;s distance from downstream outlet.</span>
<span class="sd">            fe (float or vector of float): FSP&#39;s elevation. Can be a vector</span>
<span class="sd">            gx1 (float): gauge1&#39;s distance from downstream outlet</span>
<span class="sd">            ge1 (float): gauge1&#39;s elevation</span>
<span class="sd">            gy1 (float): gauge1&#39;s DOF</span>
<span class="sd">            gx2 (float): gauge2&#39;s distance from downstream outlet</span>
<span class="sd">            ge2 (float): gauge2&#39;s elevation</span>
<span class="sd">            gy2 (float): gauge2&#39;s DOF</span>
<span class="sd">            weightingType (str): &#39;V&#39; for vertical distance-based or &#39;H&#39; for horizontal distance-based, default is &#39;V&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            float or vector of float: interpolated DOF at fx</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weightingType</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
        <span class="c1"># distance-based (hirizontal) linear interpolation</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="n">gy1</span><span class="o">+</span><span class="p">(</span><span class="n">fx</span><span class="o">-</span><span class="n">gx1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gx2</span><span class="o">-</span><span class="n">gx1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">gy2</span><span class="o">-</span><span class="n">gy1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># elevation-based (vertical) linear interpolation</span>
        <span class="c1"># when two gauges have the same elevation, using distance-based (horizontal) interpolation    </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ge1</span> <span class="o">==</span> <span class="n">ge2</span><span class="p">):</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">gy1</span><span class="o">+</span><span class="p">(</span><span class="n">fx</span><span class="o">-</span><span class="n">gx1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gx2</span><span class="o">-</span><span class="n">gx1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">gy2</span><span class="o">-</span><span class="n">gy1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># elevation-based (vertical) interpolation</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">gy1</span><span class="o">+</span><span class="p">(</span><span class="n">fe</span><span class="o">-</span><span class="n">ge1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ge2</span><span class="o">-</span><span class="n">ge1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">gy2</span><span class="o">-</span><span class="n">gy1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fy</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.InterpDofWithGauges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">InterpDofWithGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fe</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span> <span class="n">ge</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.InterpDofWithGauges" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) using the DOFs observed at a list of gauges.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>fx</code></td>
        <td><code>vector of float</code></td>
        <td><p>FSP's distance from downstream outlet.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fe</code></td>
        <td><code>vector of float</code></td>
        <td><p>FSP's elevation.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gx</code></td>
        <td><code>vector of float</code></td>
        <td><p>gauge's distance from downstream outlet.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ge</code></td>
        <td><code>vector of float</code></td>
        <td><p>gauge's elevation.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gy</code></td>
        <td><code>vector of float</code></td>
        <td><p>gauge's DOF.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>weightingType</code></td>
        <td><code>str</code></td>
        <td><p>'V' for vertical distance-based or 'H' for horizontal distance-based, default is 'V'</p></td>
        <td><code>&#39;V&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>vector of float</code></td>
      <td><p>interpolated DOF at fx    </p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">InterpDofWithGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span><span class="n">fe</span><span class="p">,</span><span class="n">gx</span><span class="p">,</span><span class="n">ge</span><span class="p">,</span><span class="n">gy</span><span class="p">,</span><span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) using the DOFs observed at a list of gauges.</span>

<span class="sd">        Args:</span>
<span class="sd">            fx (vector of float): FSP&#39;s distance from downstream outlet.</span>
<span class="sd">            fe (vector of float): FSP&#39;s elevation.</span>
<span class="sd">            gx (vector of float): gauge&#39;s distance from downstream outlet.</span>
<span class="sd">            ge (vector of float): gauge&#39;s elevation.</span>
<span class="sd">            gy (vector of float): gauge&#39;s DOF.</span>
<span class="sd">            weightingType (str): &#39;V&#39; for vertical distance-based or &#39;H&#39; for horizontal distance-based, default is &#39;V&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            vector of float: interpolated DOF at fx    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize the return vector as NAN</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">fx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">fy</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># interpolate by gauge pairs</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gy</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># get a pair of gauges</span>
        <span class="n">gx1</span><span class="p">,</span><span class="n">ge1</span><span class="p">,</span><span class="n">gy1</span><span class="o">=</span><span class="n">gx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ge</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">gy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">gx2</span><span class="p">,</span><span class="n">ge2</span><span class="p">,</span><span class="n">gy2</span><span class="o">=</span><span class="n">gx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">ge</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">gy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># prepare the FSPs for interpolation</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">fx</span><span class="o">&gt;=</span><span class="n">gx1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fx</span><span class="o">&lt;=</span><span class="n">gx2</span><span class="p">))</span>
        <span class="n">fxi</span><span class="p">,</span> <span class="n">fei</span><span class="o">=</span><span class="n">fx</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">fe</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">fy</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpBetweenTwoGauges</span><span class="p">(</span><span class="n">fxi</span><span class="p">,</span> <span class="n">fei</span><span class="p">,</span> <span class="n">gx1</span><span class="p">,</span> <span class="n">ge1</span><span class="p">,</span> <span class="n">gy1</span><span class="p">,</span> <span class="n">gx2</span><span class="p">,</span> <span class="n">ge2</span><span class="p">,</span> <span class="n">gy2</span><span class="p">,</span> <span class="n">weightingType</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fy</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.InterpolateFspDofFromGauge" class="doc doc-heading">
<code class="highlight language-python"><span class="n">InterpolateFspDofFromGauge</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gaugeFspDf</span><span class="p">,</span> <span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">,</span> <span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.InterpolateFspDofFromGauge" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) from observed gauge DOFs using distance-(horizontal) or 
elevation-based (vertical) linear interpolation. Different from EstimateFspDofFromGauge(), 
this function assumes gauge FSPs already have their DOF calculated!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are located</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugeFspDf</code></td>
        <td><code>data frame</code></td>
        <td><p>a data frame of gauge FSPs (i.e., FSPs to which gauges are snapped). It should have at least 4 columns ['lib_name','FspX','FspY','Dof'].</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>minGaugeDof</code></td>
        <td><code>float</code></td>
        <td><p>min DOF a gauge should have, by default is 1 cm = 0.0328083989501312 foot</p></td>
        <td><code>0.0328084</code></td>
      </tr>
      <tr>
        <td><code>weightingType</code></td>
        <td><code>str</code></td>
        <td><p>'V' for vertical distance-based or 'H' for horizontal distance-based, default is 'V'</p></td>
        <td><code>&#39;V&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with interpolated FSP DOFs.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">InterpolateFspDofFromGauge</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gaugeFspDf</span><span class="p">,</span><span class="n">minGaugeDof</span><span class="o">=</span><span class="mf">0.0328084</span><span class="p">,</span><span class="n">weightingType</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate FSP DOF (Depth of Flow, i.e., FSP stage) from observed gauge DOFs using distance-(horizontal) or </span>
<span class="sd">        elevation-based (vertical) linear interpolation. Different from EstimateFspDofFromGauge(), </span>
<span class="sd">        this function assumes gauge FSPs already have their DOF calculated!</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are located</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gaugeFspDf (data frame): a data frame of gauge FSPs (i.e., FSPs to which gauges are snapped). It should have at least 4 columns [&#39;lib_name&#39;,&#39;FspX&#39;,&#39;FspY&#39;,&#39;Dof&#39;].</span>
<span class="sd">            minGaugeDof (float): min DOF a gauge should have, by default is 1 cm = 0.0328083989501312 foot</span>
<span class="sd">            weightingType (str): &#39;V&#39; for vertical distance-based or &#39;H&#39; for horizontal distance-based, default is &#39;V&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with interpolated FSP DOFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># select the gauge FSPs in the library</span>
    <span class="n">gaugeFspDf</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;lib_name&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">libName</span><span class="p">]</span>

    <span class="c1"># read in FSP and stream order network files</span>
    <span class="n">fspFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspInfoFileName</span><span class="p">)</span>
    <span class="n">strOrdFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">strOrdNetFileName</span><span class="p">)</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fspFile</span><span class="p">)</span> 
    <span class="n">strOrdDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">strOrdFile</span><span class="p">)</span> 

    <span class="c1"># reset gauge FSP DOF, if it&#39;s &lt; 0 or nodata, to minGaugeDof</span>
    <span class="n">gaugeFspDf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minGaugeDof</span><span class="p">)</span><span class="o">|</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">minGaugeDof</span>
    <span class="c1"># print(gaugeFspDf)</span>

    <span class="c1"># create an empty DF to store interpolated FSP DOFs</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">])</span>
    <span class="c1"># interpolate DoF for each stream order from low to high (low order means high priority!)</span>
    <span class="c1"># get the stream orders with gauges on them</span>
    <span class="n">strOrds</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strOrds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No stream order found for the gauges!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="nb">ord</span> <span class="ow">in</span> <span class="n">strOrds</span><span class="p">:</span>
        <span class="c1"># gauges on the stream order</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeFspDf</span><span class="p">[</span><span class="n">gaugeFspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># create the upstream ending gauge assuming a level water elevation at the gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get upstream gauge&#39;s segment IDs</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">upSegId</span><span class="p">,</span> <span class="n">gElev</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">t</span> 
        <span class="c1"># get segment FSPs and find the level-off FSP</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">upSegId</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># tell pandas we want a copy to avoid &quot;SettingWithCopyWarning&quot;</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gElev</span><span class="o">+</span><span class="n">dof</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># check if the ending gauge is the gauge itself</span>
        <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
            <span class="c1"># the gauge is the ending gauge.</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usEndGauge</span> <span class="o">=</span> <span class="n">t</span>
        <span class="c1"># print(usEndGauge)</span>

        <span class="c1">#</span>
        <span class="c1"># create downstream ending gauge</span>
        <span class="c1">#</span>
        <span class="c1"># get the downstream order and junction FSP&#39;s coordinates</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">strOrdDf</span><span class="p">[</span><span class="n">strOrdDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;DsStrOrd&#39;</span><span class="p">,</span><span class="s1">&#39;JunctionFspX&#39;</span><span class="p">,</span> <span class="s1">&#39;JunctionFspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dsStrOrd</span><span class="p">,</span><span class="n">fspx</span><span class="p">,</span><span class="n">fspy</span> <span class="o">=</span> <span class="n">t</span> 

        <span class="c1"># whether there is a junction/confluence gauge</span>
        <span class="k">if</span> <span class="n">dsStrOrd</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># there is a downstream order. see whether the junction&#39;s DOF has an interpolated DOF</span>
            <span class="n">juncDf</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspx</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">fspy</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">juncDf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Junction has DOF. Create downstream ending gauge with the junction FSP</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">juncDf</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">juncDf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># No downstream order or junction FSP</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dsStrOrd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">juncDf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Create downstream ending gauge with the last FSP in the segment</span>
            <span class="c1"># get the downstream and upstream segment IDs</span>
            <span class="n">dsSegId</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;SegId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># get the first FSP on the downstream segment</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;SegId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">dsSegId</span><span class="p">]</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>
            <span class="c1"># check if the ending gauge is the gauge itself</span>
            <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># same as: tx,ty = t[[&#39;FspX&#39;,&#39;FspY&#39;]].values.flatten().tolist()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gx</span><span class="o">==</span><span class="n">tx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gy</span><span class="o">==</span><span class="n">ty</span><span class="p">):</span>
                <span class="c1"># the gauge is the ending gauge.</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># an empty DF</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dsEndGauge</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">dsEndGauge</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># print(dsEndGauge)</span>

        <span class="c1"># put all the gauges together</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(usEndGauge)</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">usEndGauge</span><span class="p">])</span>
        <span class="c1"># gaugeOrd = gaugeOrd.append(dsEndGauge)</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gaugeOrd</span><span class="p">,</span><span class="n">dsEndGauge</span><span class="p">])</span>
        <span class="c1"># print(f&quot;Gauges with DOFs on stream order ({ord}): \n&quot;,gaugeOrd)</span>

        <span class="c1"># calculate the min and max downstream distance</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">maxDist</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># select the FSPs on the stream order</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;StrOrd&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">ord</span><span class="p">][[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;DsDist&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>
        <span class="n">fspOrd</span> <span class="o">=</span> <span class="n">fspOrd</span><span class="p">[(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minDist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxDist</span><span class="p">)]</span>
        <span class="n">fx</span><span class="p">,</span> <span class="n">fe</span> <span class="o">=</span> <span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span><span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># prepare gauges</span>
        <span class="n">gaugeOrd</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;DsDist&#39;</span><span class="p">)</span>
        <span class="n">gx</span><span class="p">,</span> <span class="n">ge</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;DsDist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">gaugeOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># interpolate</span>
        <span class="n">fspOrd</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpDofWithGauges</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span><span class="n">fe</span><span class="p">,</span><span class="n">gx</span><span class="p">,</span><span class="n">ge</span><span class="p">,</span><span class="n">gy</span><span class="p">,</span><span class="n">weightingType</span><span class="p">)</span>

        <span class="c1"># append the interpolated SFPs</span>
        <span class="c1"># fspDof = fspDof.append(fspOrd,ignore_index=True)</span>
        <span class="n">fspDof</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">fspDof</span><span class="p">,</span><span class="n">fspOrd</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># print(fspDof)</span>

    <span class="c1"># select columns</span>
    <span class="n">fspDof</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;Dof&#39;</span><span class="p">]]</span>
    <span class="c1"># fspDof = fspDof[[&#39;FspId&#39;,&#39;DsDist&#39;,&#39;FilledElev&#39;,&#39;Dof&#39;]] # keep more columns for checking the interpolation</span>
    <span class="c1"># print(fspDof)</span>

    <span class="c1"># return interpolated DOF for the FSPs</span>
    <span class="k">return</span> <span class="n">fspDof</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapFloodDepthWithTiles" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapFloodDepthWithTiles</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">outMapFolder</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapFloodDepthWithTiles" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map flood depth with tiled library based on FSP DOF and AOI extent</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are stored</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outMapFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the mapped tiles will be saved</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>Return</code></td>
        <td></td>
        <td></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapFloodDepthWithTiles</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map flood depth with tiled library based on FSP DOF and AOI extent</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are stored</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            outMapFolder (str): the folder where the mapped tiles will be saved</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None</span>

<span class="sd">            Return:</span>
<span class="sd">                list: a list of mapped tile names as GeoTif files</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create the folder for generating tile maps</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Read lib meta data file</span>
    <span class="c1">#</span>
    <span class="n">metaDataFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">metaDataFileName</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metaDataFile</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">jf</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">jf</span><span class="p">)</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;CellSize&#39;</span><span class="p">]</span>
    <span class="n">srText</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;SpatialReference&#39;</span><span class="p">]</span>
    <span class="n">libSr</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_wkt</span><span class="p">(</span><span class="n">srText</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># decide the tiles to map</span>
    <span class="c1">#</span>
    <span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span> <span class="o">=</span> <span class="n">Tiles2Map</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles need to be mapped:&#39;</span><span class="p">,</span><span class="n">tileIds</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># map the selected tiles</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">tileIds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tileTifs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tileTifs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span><span class="p">):</span>
            <span class="n">tif</span><span class="o">=</span><span class="n">MapOneTile</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">tileTifs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tileTifs</span><span class="p">:</span> <span class="c1"># empty list</span>
            <span class="n">tileTifs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">tileTifs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapFloodDepthWithTilesAsDag" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapFloodDepthWithTilesAsDag</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">outMapFolder</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapFloodDepthWithTilesAsDag" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map flood depth with tiled library based on FSP DOF and AOI extent as a Directed Acyclic Graph (DAG)</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are stored</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outMapFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the mapped tiles will be saved</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>Return</code></td>
        <td></td>
        <td></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapFloodDepthWithTilesAsDag</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map flood depth with tiled library based on FSP DOF and AOI extent as a Directed Acyclic Graph (DAG)</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are stored</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            outMapFolder (str): the folder where the mapped tiles will be saved</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None</span>

<span class="sd">            Return:</span>
<span class="sd">                tuple: a Directed Acyclic Graph (DAG) and the root node name</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create the folder for generating tile maps</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Read lib meta data file</span>
    <span class="c1">#</span>
    <span class="n">metaDataFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">metaDataFileName</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metaDataFile</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">jf</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">jf</span><span class="p">)</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;CellSize&#39;</span><span class="p">]</span>
    <span class="n">srText</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;SpatialReference&#39;</span><span class="p">]</span>
    <span class="n">libSr</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_wkt</span><span class="p">(</span><span class="n">srText</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># decide the tiles to map</span>
    <span class="c1">#</span>
    <span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span> <span class="o">=</span> <span class="n">Tiles2Map</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles need to be mapped:&#39;</span><span class="p">,</span><span class="n">tileIds</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># map the selected tiles</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">tileIds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dagRootName</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span><span class="p">):</span>
            <span class="c1"># tif=MapOneTileBlob(libBlobSerClient,libName,tid,fppExtent,cellSize,libSr,fileFormat,mapContainerClient,fspDof,aoiExtent)</span>
            <span class="n">dag</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;MapOneTile_</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">MapOneTile</span><span class="p">,</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="p">)</span>

        <span class="c1"># MosaicGtifsBlob(mapContClient,tileTifs,outName,keepTileMaps)  </span>
        <span class="n">dagRootName</span> <span class="o">=</span> <span class="s1">&#39;MapTiles&#39;</span>
        <span class="c1"># dag[dagRootName] = (MosaicGtifsBlob,mapContClient,list(dag.keys()),outName,False)</span>
        <span class="n">dag</span><span class="p">[</span><span class="n">dagRootName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetTileTifs</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">dag</span><span class="p">,</span><span class="n">dagRootName</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapFloodDepthWithTilesBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapFloodDepthWithTilesBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">mapContainerClient</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapFloodDepthWithTilesBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map flood depth with tiled library based on FSP DOF and AOI extent on Microsoft Planetary Computer using data in Azure Blob Storage.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a BlobServiceClient object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mapContainerClient</code></td>
        <td><code>ContainerClient</code></td>
        <td><p>a ContainerClient object for the container to store the mapped tiles</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list</code></td>
      <td><p>a list of mapped tile names as GeoTif files</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapFloodDepthWithTilesBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">mapContainerClient</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map flood depth with tiled library based on FSP DOF and AOI extent on Microsoft Planetary Computer using data in Azure Blob Storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a BlobServiceClient object</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            mapContainerClient (ContainerClient): a ContainerClient object for the container to store the mapped tiles</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None</span>

<span class="sd">        Return:</span>
<span class="sd">            list: a list of mapped tile names as GeoTif files</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Read lib meta data file</span>
    <span class="c1">#    </span>
    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>
    <span class="c1"># get blob client</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">metaDataFileName</span><span class="p">)</span>
    <span class="c1"># read the blob into memory</span>
    <span class="n">streamdownloader</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">download_blob</span><span class="p">()</span>
    <span class="n">md</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">streamdownloader</span><span class="o">.</span><span class="n">readall</span><span class="p">())</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;CellSize&#39;</span><span class="p">]</span>
    <span class="n">srText</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;SpatialReference&#39;</span><span class="p">]</span>
    <span class="n">libSr</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_wkt</span><span class="p">(</span><span class="n">srText</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># decide the tiles to map</span>
    <span class="c1">#</span>
    <span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span> <span class="o">=</span> <span class="n">Tiles2MapBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles need to be mapped:&#39;</span><span class="p">,</span><span class="n">tileIds</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># map the selected tiles</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">tileIds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tileTifs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tileTifs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span><span class="p">):</span>
            <span class="n">tif</span><span class="o">=</span><span class="n">MapOneTileBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">mapContainerClient</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">tileTifs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Actual tiles mapped:&#39;</span><span class="p">,</span><span class="n">tileTifs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tileTifs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapFloodDepthWithTilesBlobAsDag" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapFloodDepthWithTilesBlobAsDag</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">mapContainerClient</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapFloodDepthWithTilesBlobAsDag" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map flood depth with tiled library based on FSP DOF and AOI extent on Microsoft Planetary Computer using data in Azure Blob Storage 
as a Directed Acyclic Graph (DAG).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a BlobServiceClient object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mapContainerClient</code></td>
        <td><code>ContainerClient</code></td>
        <td><p>a ContainerClient object for the container to store the mapped tiles</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>a Directed Acyclic Graph (DAG) and the root node name</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapFloodDepthWithTilesBlobAsDag</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">mapContainerClient</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map flood depth with tiled library based on FSP DOF and AOI extent on Microsoft Planetary Computer using data in Azure Blob Storage </span>
<span class="sd">        as a Directed Acyclic Graph (DAG).</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a BlobServiceClient object</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            mapContainerClient (ContainerClient): a ContainerClient object for the container to store the mapped tiles</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None</span>

<span class="sd">        Return:</span>
<span class="sd">            tuple: a Directed Acyclic Graph (DAG) and the root node name</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Read lib meta data file</span>
    <span class="c1">#    </span>
    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>
    <span class="c1"># get blob client</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">metaDataFileName</span><span class="p">)</span>
    <span class="c1"># read the blob into memory</span>
    <span class="n">streamdownloader</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">download_blob</span><span class="p">()</span>
    <span class="n">md</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">streamdownloader</span><span class="o">.</span><span class="n">readall</span><span class="p">())</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;CellSize&#39;</span><span class="p">]</span>
    <span class="n">srText</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;SpatialReference&#39;</span><span class="p">]</span>
    <span class="n">libSr</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_wkt</span><span class="p">(</span><span class="n">srText</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># decide the tiles to map</span>
    <span class="c1">#</span>
    <span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span> <span class="o">=</span> <span class="n">Tiles2MapBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles need to be mapped:&#39;</span><span class="p">,</span><span class="n">tileIds</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># map the selected tiles</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">tileIds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dagRootName</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tileIds</span><span class="p">,</span><span class="n">fppExtents</span><span class="p">):</span>
            <span class="c1"># tif=MapOneTileBlob(libBlobSerClient,libName,tid,fppExtent,cellSize,libSr,fileFormat,mapContainerClient,fspDof,aoiExtent)</span>
            <span class="n">dag</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;MapOneTileBlob_</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">MapOneTileBlob</span><span class="p">,</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">mapContainerClient</span><span class="p">,</span><span class="n">fspDof</span><span class="p">,</span><span class="n">aoiExtent</span><span class="p">)</span>

        <span class="c1"># MosaicGtifsBlob(mapContClient,tileTifs,outName,keepTileMaps)  </span>
        <span class="n">dagRootName</span> <span class="o">=</span> <span class="s1">&#39;MapTiles&#39;</span>
        <span class="c1"># dag[dagRootName] = (MosaicGtifsBlob,mapContClient,list(dag.keys()),outName,False)</span>
        <span class="n">dag</span><span class="p">[</span><span class="n">dagRootName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetTileTifs</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">dag</span><span class="p">,</span><span class="n">dagRootName</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapOneTile" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapOneTile</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">libSr</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">outMapFolder</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapOneTile" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map one tile as a GeoTif file based on FSP DOF and AOI extent</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are stored</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tid</code></td>
        <td><code>int</code></td>
        <td><p>the tile ID</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fppExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the FPPs in the tile [minX,maxX,minY,maxY]</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cellSize</code></td>
        <td><code>float</code></td>
        <td><p>the cell size of the raster</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libSr</code></td>
        <td><code>str</code></td>
        <td><p>the spatial reference of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outMapFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the mapped tiles will be saved</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None </p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str</code></td>
      <td><p>the name of the mapped tile as a GeoTif file</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapOneTile</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map one tile as a GeoTif file based on FSP DOF and AOI extent</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are stored</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            tid (int): the tile ID</span>
<span class="sd">            fppExtent (list): the extent of the FPPs in the tile [minX,maxX,minY,maxY]</span>
<span class="sd">            cellSize (float): the cell size of the raster</span>
<span class="sd">            libSr (str): the spatial reference of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            outMapFolder (str): the folder where the mapped tiles will be saved</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None </span>

<span class="sd">        Return:</span>
<span class="sd">            str: the name of the mapped tile as a GeoTif file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># print(&#39;Mapping tile: &#39;, tid)</span>
    <span class="c1"># print(&#39;Read tile file ...&#39;)</span>
    <span class="k">if</span> <span class="n">fileFormat</span> <span class="o">==</span> <span class="s1">&#39;snappy&#39;</span><span class="p">:</span>
        <span class="c1"># tileName = os.path.join(libFolder, libName, tileFileMainName+&#39;_&#39;+str(tid)+&#39;.gzip&#39;) # for gzip</span>
        <span class="n">tileName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">tileFileMainName</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.snz&#39;</span><span class="p">)</span> <span class="c1"># for snappy</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">tileName</span><span class="p">)</span> <span class="c1"># the original column datatypes are kept when read into a DF!</span>
    <span class="k">elif</span> <span class="n">fileFormat</span> <span class="o">==</span> <span class="s1">&#39;mat&#39;</span><span class="p">:</span>
        <span class="c1"># Tiles can also be saved as .mat </span>
        <span class="n">tileName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span>  <span class="n">tileFileMainName</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.mat&#39;</span><span class="p">)</span>
        <span class="c1"># tileName = os.path.join(&#39;~/fldpln/libraries&#39;, libName,  tileFileMainName+&#39;_&#39;+str(tid)+&#39;.mat&#39;)</span>
        <span class="c1"># read from mat file</span>
        <span class="n">matFile</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">tileName</span><span class="p">)</span>
        <span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">matFile</span><span class="p">[</span><span class="s1">&#39;FspFpps&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">relColumnNames</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">matFile</span><span class="p">[</span><span class="s1">&#39;DtfFilledDepth&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">relColumnNames</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::])</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unsupported file format!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Turn FSP-FPP relations to a 2D array</span>
    <span class="n">dtfArray</span><span class="p">,</span> <span class="n">noData</span><span class="p">,</span> <span class="n">mapMinX</span><span class="p">,</span> <span class="n">mapMaxY</span> <span class="o">=</span> <span class="n">TileFspFppRelations2Array</span><span class="p">(</span><span class="n">tdf</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">fspDof</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="p">)</span>

    <span class="c1"># map the tile</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dtfArray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> <span class="c1"># needs to be mapped</span>
        <span class="c1"># Create and save map as a GeoTif file</span>
        <span class="c1"># print(&#39;Saving map as a TIF raster ...&#39;)</span>

        <span class="c1"># output file name</span>
        <span class="n">rasterName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">libName</span><span class="o">+</span><span class="s1">&#39;_tile_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>

        <span class="c1"># create GeoTIFF profile</span>
        <span class="c1"># create an Affine transformation from upper left corner coordinates and pixel sizes</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">from_origin</span><span class="p">(</span><span class="n">mapMinX</span><span class="p">,</span> <span class="n">mapMaxY</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">dtfArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
            <span class="n">width</span> <span class="o">=</span> <span class="n">dtfArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">dtfArray</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">libSr</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="n">noData</span>
        <span class="p">)</span>

        <span class="c1"># write to COG file</span>
        <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
            <span class="c1"># write the array to a memory file</span>
            <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
                <span class="c1"># Populate the input file with numpy array</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dtfArray</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># open the memory file reading</span>
            <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
                <span class="n">dst_profile</span> <span class="o">=</span> <span class="n">cog_profiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;deflate&quot;</span><span class="p">)</span>
                <span class="n">cog_translate</span><span class="p">(</span>
                    <span class="n">mem</span><span class="p">,</span>
                    <span class="n">rasterName</span><span class="p">,</span>
                    <span class="n">dst_profile</span><span class="p">,</span>
                    <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">rasterName</span>

        <span class="c1"># # code to save tile as regular GeoTIFF file</span>
        <span class="c1"># with rasterio.open(rasterName, &#39;w&#39;, **profile) as tifRaster:</span>
        <span class="c1">#     tifRaster.write(dtfArray, 1)</span>
        <span class="c1"># return rasterName</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MapOneTileBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MapOneTileBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">libSr</span><span class="p">,</span> <span class="n">fileFormat</span><span class="p">,</span> <span class="n">mapContainerClient</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MapOneTileBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Map one tile as a GeoTif file based on FSP DOF and AOI extent on Microsoft Planetary Computer using Azure Blob Storage.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a BlobServiceClient object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tid</code></td>
        <td><code>int</code></td>
        <td><p>the tile ID</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fppExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the FPPs in the tile [minX,maxX,minY,maxY]</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cellSize</code></td>
        <td><code>float</code></td>
        <td><p>the cell size of the raster</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libSr</code></td>
        <td><code>str</code></td>
        <td><p>the spatial reference of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fileFormat</code></td>
        <td><code>str</code></td>
        <td><p>the file format of the tile, 'snappy' or 'mat'</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mapContainerClient</code></td>
        <td><code>ContainerClient</code></td>
        <td><p>a ContainerClient object for the container to store the mapped tiles</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY], default is None</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str</code></td>
      <td><p>the name of the mapped tile as a GeoTif file</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MapOneTileBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span><span class="n">fppExtent</span><span class="p">,</span><span class="n">cellSize</span><span class="p">,</span><span class="n">libSr</span><span class="p">,</span><span class="n">fileFormat</span><span class="p">,</span><span class="n">mapContainerClient</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Map one tile as a GeoTif file based on FSP DOF and AOI extent on Microsoft Planetary Computer using Azure Blob Storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a BlobServiceClient object</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            tid (int): the tile ID</span>
<span class="sd">            fppExtent (list): the extent of the FPPs in the tile [minX,maxX,minY,maxY]</span>
<span class="sd">            cellSize (float): the cell size of the raster</span>
<span class="sd">            libSr (str): the spatial reference of the library</span>
<span class="sd">            fileFormat (str): the file format of the tile, &#39;snappy&#39; or &#39;mat&#39;</span>
<span class="sd">            mapContainerClient (ContainerClient): a ContainerClient object for the container to store the mapped tiles</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY], default is None</span>

<span class="sd">        Return:</span>
<span class="sd">            str: the name of the mapped tile as a GeoTif file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>

    <span class="c1"># print(&#39;Mapping tile: &#39;, tid)</span>
    <span class="c1"># print(&#39;Read tile file ...&#39;)</span>
    <span class="k">if</span> <span class="n">fileFormat</span> <span class="o">==</span> <span class="s1">&#39;snappy&#39;</span><span class="p">:</span>
        <span class="n">tileName</span> <span class="o">=</span> <span class="n">tileFileMainName</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.snz&#39;</span> <span class="c1"># for snappy</span>
        <span class="c1"># get blob client</span>
        <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">tileName</span><span class="p">)</span>
        <span class="c1"># create a SAS token</span>
        <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
            <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
            <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
            <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
            <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
            <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># construct the URL</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
        <span class="c1"># read the blob</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fileFormat</span> <span class="o">==</span> <span class="s1">&#39;mat&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not supported yet!&#39;</span><span class="p">)</span>
        <span class="c1"># # Tiles can also be saved as .mat </span>
        <span class="c1"># tileName = os.path.join(libFolder, libName,  tileFileMainName+&#39;_&#39;+str(tid)+&#39;.mat&#39;)</span>
        <span class="c1"># # tileName = os.path.join(&#39;~/fldpln/libraries&#39;, libName,  tileFileMainName+&#39;_&#39;+str(tid)+&#39;.mat&#39;)</span>
        <span class="c1"># # read from mat file</span>
        <span class="c1"># matFile = sio.loadmat(tileName)</span>
        <span class="c1"># df1 = pd.DataFrame(matFile[&#39;FspFpps&#39;], columns=relColumnNames[0:3])</span>
        <span class="c1"># df2 = pd.DataFrame(matFile[&#39;DtfFilledDepth&#39;], columns=relColumnNames[-2::])</span>
        <span class="c1"># tdf = pd.concat([df1, df2], axis=1)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unsupported file format!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Turn FSP-FPP relations to a 2D array</span>
    <span class="n">dtfArray</span><span class="p">,</span> <span class="n">noData</span><span class="p">,</span> <span class="n">mapMinX</span><span class="p">,</span> <span class="n">mapMaxY</span> <span class="o">=</span> <span class="n">TileFspFppRelations2Array</span><span class="p">(</span><span class="n">tdf</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">fspDof</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="p">)</span>

    <span class="c1"># map the tile</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dtfArray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> <span class="c1"># needs to be mapped</span>
        <span class="c1"># Create and save map as a GeoTif file</span>
        <span class="c1"># print(&#39;Saving map as a TIF raster ...&#39;)</span>

        <span class="c1"># output file name</span>
        <span class="n">rasterName</span> <span class="o">=</span> <span class="n">libName</span><span class="o">+</span><span class="s1">&#39;_tile_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span>

        <span class="c1"># create GeoTIFF profile</span>
        <span class="c1"># create an Affine transformation from upper left corner coordinates and pixel sizes</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">from_origin</span><span class="p">(</span><span class="n">mapMinX</span><span class="p">,</span> <span class="n">mapMaxY</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">dtfArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
            <span class="n">width</span> <span class="o">=</span> <span class="n">dtfArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">dtfArray</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">libSr</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="n">noData</span>
        <span class="p">)</span>

        <span class="c1"># write the array to blob storage as a COG file</span>
        <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
            <span class="c1"># write the array to a memory file</span>
            <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
                <span class="c1"># Populate the input file with numpy array</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dtfArray</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># open the memory file reading</span>
            <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
                <span class="n">dst_profile</span> <span class="o">=</span> <span class="n">cog_profiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;deflate&quot;</span><span class="p">)</span>
                <span class="c1"># translate the memfile into a COG memfile</span>
                <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">mem_dst</span><span class="p">:</span>
                    <span class="c1"># Important, we pass `mem_dst.name` as output dataset path</span>
                    <span class="n">cog_translate</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mem_dst</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dst_profile</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># upload the mem file to blob storage</span>
                    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">mapContainerClient</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">rasterName</span><span class="p">)</span>
                    <span class="n">blob_client</span><span class="o">.</span><span class="n">upload_blob</span><span class="p">(</span><span class="n">mem_dst</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rasterName</span>

<span class="c1">#         # code to save tile as a regular GeoTIFF file</span>
<span class="c1">#         rasterName = libName+&#39;_tile_&#39;+str(tid)+&#39;.tif&#39;</span>
<span class="c1">#         # create an Affine transformation from upper left corner coordinates and pixel sizes</span>
<span class="c1">#         transform = rasterio.transform.from_origin(mapMinX, mapMaxY, cellSize, cellSize)</span>

<span class="c1">#         # Write data to an in-memory io.BytesIO buffer</span>
<span class="c1">#         # open an in-memory buffer</span>
<span class="c1">#         with io.BytesIO() as buffer:</span>
<span class="c1">#             # write Geotif to the buffer</span>
<span class="c1">#             with rasterio.open(buffer, &#39;w&#39;, driver=&#39;GTiff&#39;,</span>
<span class="c1">#                                     height = dtfArray.shape[0], width = dtfArray.shape[1],</span>
<span class="c1">#                                     count=1, dtype=str(dtfArray.dtype),</span>
<span class="c1">#                                     crs=libSr,</span>
<span class="c1">#                                     transform=transform,</span>
<span class="c1">#                                     nodata=noData) as tifRaster:</span>
<span class="c1">#                 tifRaster.write(dtfArray, 1)</span>
<span class="c1">#             # upload the in-memory tif to blob storage</span>
<span class="c1">#             buffer.seek(0)</span>
<span class="c1">#             blob_client = mapContainerClient.get_blob_client(rasterName)</span>
<span class="c1">#             blob_client.upload_blob(buffer, overwrite=True)</span>

<span class="c1">#         return rasterName</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MosaicGtifs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MosaicGtifs</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span> <span class="n">gtifs</span><span class="p">,</span> <span class="n">mosaicTifName</span><span class="p">,</span> <span class="n">keepTifs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MosaicGtifs" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Mosaic a list of GeoTifs into one GeoTif file using rasterio.merge module.
See https://medium.com/spatial-data-science/how-to-mosaic-merge-raster-data-in-python-fb18e44f3c8.
This func may cause memory overflow as the merge() first creates the mosaiced array in memory!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>outMapFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the mosaiced tif will be saved</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gtifs</code></td>
        <td><code>list</code></td>
        <td><p>a list of tile GeoTifs to be mosaiced</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mosaicTifName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the mosaiced GeoTif file</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>keepTifs</code></td>
        <td><code>bool</code></td>
        <td><p>whether to keep the tile GeoTifs, default is False</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str</code></td>
      <td><p>the name of the mosaiced GeoTif</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MosaicGtifs</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">gtifs</span><span class="p">,</span><span class="n">mosaicTifName</span><span class="p">,</span> <span class="n">keepTifs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Mosaic a list of GeoTifs into one GeoTif file using rasterio.merge module.</span>
<span class="sd">        See https://medium.com/spatial-data-science/how-to-mosaic-merge-raster-data-in-python-fb18e44f3c8.</span>
<span class="sd">        This func may cause memory overflow as the merge() first creates the mosaiced array in memory!</span>

<span class="sd">        Args:</span>
<span class="sd">            outMapFolder (str): the folder where the mosaiced tif will be saved</span>
<span class="sd">            gtifs (list): a list of tile GeoTifs to be mosaiced</span>
<span class="sd">            mosaicTifName (str): the name of the mosaiced GeoTif file</span>
<span class="sd">            keepTifs (bool): whether to keep the tile GeoTifs, default is False</span>

<span class="sd">        Return:</span>
<span class="sd">            str: the name of the mosaiced GeoTif</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># open all the Gtifs</span>
    <span class="n">ras2Mosaic</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gtif</span> <span class="ow">in</span> <span class="n">gtifs</span><span class="p">:</span> <span class="c1"># assuming no None item in the list</span>
        <span class="n">gtifFullName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">gtif</span><span class="p">)</span>
        <span class="n">ras</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">gtifFullName</span><span class="p">)</span>
        <span class="n">ras2Mosaic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ras</span><span class="p">)</span>

    <span class="c1"># create array representing all source rasters mosaicked together</span>
    <span class="n">mosaicedArray</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">ras2Mosaic</span><span class="p">)</span>

    <span class="c1"># close all the tifs</span>
    <span class="k">for</span> <span class="n">ras</span> <span class="ow">in</span> <span class="n">ras2Mosaic</span><span class="p">:</span>
        <span class="n">ras</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Prepareto write the array into one tif file</span>
    <span class="n">outMeta</span> <span class="o">=</span> <span class="n">ras2Mosaic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">outMeta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">mosaicedArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">mosaicedArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;transform&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># write to COG file</span>
    <span class="n">mosaicTifFullName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outMapFolder</span><span class="p">,</span><span class="n">mosaicTifName</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
        <span class="c1"># write the array to a memory file</span>
        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="o">**</span><span class="n">outMeta</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
            <span class="c1"># Populate the input file with numpy array</span>
            <span class="n">mem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mosaicedArray</span><span class="p">)</span>
        <span class="c1"># open the memory file reading</span>
        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
            <span class="n">dst_profile</span> <span class="o">=</span> <span class="n">cog_profiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;deflate&quot;</span><span class="p">)</span>
            <span class="n">cog_translate</span><span class="p">(</span>
                <span class="n">mem</span><span class="p">,</span>
                <span class="n">mosaicTifFullName</span><span class="p">,</span>
                <span class="n">dst_profile</span><span class="p">,</span>
                <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># # save the mosaiced array to a regular GeoTIFF file</span>
    <span class="c1"># mosaicTifFullName = os.path.join(outMapFolder,mosaicTifName)</span>
    <span class="c1"># with rasterio.open(mosaicTifFullName, &#39;w&#39;, **outMeta) as m:</span>
    <span class="c1">#     m.write(mosaicedArray)</span>

    <span class="c1"># delete tile maps</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keepTifs</span><span class="p">:</span> 
        <span class="c1"># print(&#39;Delete tile maps ...&#39;)</span>
        <span class="k">for</span> <span class="n">tm</span> <span class="ow">in</span> <span class="n">gtifs</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mosaicTifFullName</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MosaicGtifsBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MosaicGtifsBlob</span><span class="p">(</span><span class="n">mapContClient</span><span class="p">,</span> <span class="n">gtifs</span><span class="p">,</span> <span class="n">outGtif</span><span class="p">,</span> <span class="n">keepTifs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MosaicGtifsBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Mosaic a list of GeoTifs into one GeoTif file using rasterio.merge module on Microsoft Planetary Computer using data in Azure Blob Storage.
See https://medium.com/spatial-data-science/how-to-mosaic-merge-raster-data-in-python-fb18e44f3c8.
This func may cause memory overflow as the merge() first creates the mosaiced array in memory!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mapContClient</code></td>
        <td><code>ContainerClient</code></td>
        <td><p>a ContainerClient object for the container to store the mosaiced tif</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gtifs</code></td>
        <td><code>list</code></td>
        <td><p>a list of tile GeoTifs to be mosaiced</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outGtif</code></td>
        <td><code>str</code></td>
        <td><p>the name of the mosaiced GeoTif file</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>keepTifs</code></td>
        <td><code>bool</code></td>
        <td><p>whether to keep the tile GeoTifs, default is False</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>None</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MosaicGtifsBlob</span><span class="p">(</span><span class="n">mapContClient</span><span class="p">,</span> <span class="n">gtifs</span><span class="p">,</span> <span class="n">outGtif</span><span class="p">,</span> <span class="n">keepTifs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Mosaic a list of GeoTifs into one GeoTif file using rasterio.merge module on Microsoft Planetary Computer using data in Azure Blob Storage.</span>
<span class="sd">        See https://medium.com/spatial-data-science/how-to-mosaic-merge-raster-data-in-python-fb18e44f3c8.</span>
<span class="sd">        This func may cause memory overflow as the merge() first creates the mosaiced array in memory!</span>

<span class="sd">        Args:</span>
<span class="sd">            mapContClient (ContainerClient): a ContainerClient object for the container to store the mosaiced tif</span>
<span class="sd">            gtifs (list): a list of tile GeoTifs to be mosaiced</span>
<span class="sd">            outGtif (str): the name of the mosaiced GeoTif file</span>
<span class="sd">            keepTifs (bool): whether to keep the tile GeoTifs, default is False</span>

<span class="sd">        Return:</span>
<span class="sd">            None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># open all the Gtifs</span>
    <span class="n">ras2Mosaic</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gtif</span> <span class="ow">in</span> <span class="n">gtifs</span><span class="p">:</span> <span class="c1"># assuming no None tif file names in the list</span>
        <span class="n">blob_client</span> <span class="o">=</span> <span class="n">mapContClient</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">gtif</span><span class="p">)</span>
        <span class="c1"># create a SAS token</span>
        <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
            <span class="n">mapContClient</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
            <span class="n">mapContClient</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
            <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
            <span class="n">account_key</span><span class="o">=</span><span class="n">mapContClient</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
            <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># Note that the container or the blob must have a access level of Anonymous access</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
        <span class="n">ras</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">ras2Mosaic</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ras</span><span class="p">)</span>

    <span class="c1"># create array representing all source rasters mosaicked together</span>
    <span class="n">mosaicedArray</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">ras2Mosaic</span><span class="p">)</span>

    <span class="c1"># close all the tifs</span>
    <span class="k">for</span> <span class="n">ras</span> <span class="ow">in</span> <span class="n">ras2Mosaic</span><span class="p">:</span>
        <span class="n">ras</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Prepareto write the array into one tif file</span>
    <span class="n">outMeta</span> <span class="o">=</span> <span class="n">ras2Mosaic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">outMeta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">mosaicedArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">mosaicedArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;transform&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># write the array to blob storage as a COG file</span>
    <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
        <span class="c1"># write the array to a memory file</span>
        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="o">**</span><span class="n">outMeta</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
            <span class="c1"># Populate the input file with numpy array</span>
            <span class="n">mem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mosaicedArray</span><span class="p">)</span> <span class="c1"># or mem.write(mosaicedArray,1)</span>
        <span class="c1"># open the memory file reading</span>
        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mem</span><span class="p">:</span>
            <span class="n">dst_profile</span> <span class="o">=</span> <span class="n">cog_profiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;deflate&quot;</span><span class="p">)</span>
            <span class="c1"># translate the memfile into a COG memfile</span>
            <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">mem_dst</span><span class="p">:</span>
                <span class="c1"># Important, we pass `mem_dst.name` as output dataset path</span>
                <span class="n">cog_translate</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mem_dst</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dst_profile</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># upload the mem file to blob storage</span>
                <span class="n">blob_client</span> <span class="o">=</span> <span class="n">mapContClient</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">outGtif</span><span class="p">)</span>
                <span class="n">blob_client</span><span class="o">.</span><span class="n">upload_blob</span><span class="p">(</span><span class="n">mem_dst</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  

    <span class="c1"># #</span>
    <span class="c1"># # original code to save the mosaiced array as a regular GeoTIFF file</span>
    <span class="c1"># #</span>
    <span class="c1"># # Write data to an in-memory io.BytesIO buffer</span>
    <span class="c1"># # open an in-memory buffer</span>
    <span class="c1"># with io.BytesIO() as buffer:</span>
    <span class="c1">#     # write Geotif to the buffer</span>
    <span class="c1">#     with rasterio.open(buffer, &#39;w&#39;, **outMeta) as tifRaster:</span>
    <span class="c1">#         tifRaster.write(mosaicedArray)</span>
    <span class="c1">#     # upload the in-memory tif to blob storage</span>
    <span class="c1">#     buffer.seek(0)</span>
    <span class="c1">#     blob_client = mapContClient.get_blob_client(outGtif)</span>
    <span class="c1">#     blob_client.upload_blob(buffer, overwrite=True)</span>

    <span class="c1"># delete tile maps</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keepTifs</span><span class="p">:</span> 
        <span class="c1"># print(&#39;Delete tile maps ...&#39;)</span>
        <span class="k">for</span> <span class="n">gtif</span> <span class="ow">in</span> <span class="n">gtifs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">gtif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">blob_client</span> <span class="o">=</span> <span class="n">mapContClient</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">gtif</span><span class="p">)</span>
                <span class="n">blob_client</span><span class="o">.</span><span class="n">delete_blob</span><span class="p">()</span>

    <span class="k">return</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.MosaicGtifsUsingVirtualRaster" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MosaicGtifsUsingVirtualRaster</span><span class="p">(</span><span class="n">gtifs</span><span class="p">,</span> <span class="n">outGtif</span><span class="p">)</span></code>


<a href="#fldpln.mapping.MosaicGtifsUsingVirtualRaster" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Mosaic a list of GeoTifs into one GeoTif file using GDAL virtual raster.
Easiest way of mosaic very large Gtif. Based on the video at https://www.youtube.com/watch?v=sBBMKbAj8XE</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gtifs</code></td>
        <td><code>list</code></td>
        <td><p>a list of tile GeoTifs to be mosaiced</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outGtif</code></td>
        <td><code>str</code></td>
        <td><p>the name of the mosaiced GeoTif file</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>None</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MosaicGtifsUsingVirtualRaster</span><span class="p">(</span><span class="n">gtifs</span><span class="p">,</span> <span class="n">outGtif</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Mosaic a list of GeoTifs into one GeoTif file using GDAL virtual raster.</span>
<span class="sd">        Easiest way of mosaic very large Gtif. Based on the video at https://www.youtube.com/watch?v=sBBMKbAj8XE</span>

<span class="sd">        Args:</span>
<span class="sd">            gtifs (list): a list of tile GeoTifs to be mosaiced</span>
<span class="sd">            outGtif (str): the name of the mosaiced GeoTif file</span>

<span class="sd">        Return:</span>
<span class="sd">            None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span> <span class="c1"># since gdal cannot be installed using pip, we leave the import here and it&#39;s up to the user to install gdal.</span>

    <span class="c1"># Create a XML-based virtual raster file for mosaicing</span>
    <span class="n">vrtFolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">outGtif</span><span class="p">)</span>
    <span class="n">vrtName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">outGtif</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.vrt&#39;</span>
    <span class="n">vrtFullName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vrtFolder</span><span class="p">,</span><span class="n">vrtName</span><span class="p">)</span>
    <span class="n">vrt</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">BuildVRT</span><span class="p">(</span><span class="n">vrtFullName</span><span class="p">,</span> <span class="n">gtifs</span><span class="p">)</span>

    <span class="c1"># access meta data from the first gtif</span>
    <span class="n">ras</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">gtifs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">rasMeta</span> <span class="o">=</span> <span class="n">ras</span><span class="o">.</span><span class="n">meta</span>
    <span class="c1"># get cell size in x and y</span>
    <span class="n">tran</span> <span class="o">=</span> <span class="n">rasMeta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> 
    <span class="n">xCellSize</span><span class="p">,</span> <span class="n">yCellSize</span> <span class="o">=</span> <span class="n">tran</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">tran</span><span class="o">.</span><span class="n">e</span>

    <span class="c1"># mosaic the gtifs</span>
    <span class="n">gdal</span><span class="o">.</span><span class="n">Translate</span><span class="p">(</span><span class="n">outGtif</span><span class="p">,</span> <span class="n">vrt</span><span class="p">,</span> <span class="n">xRes</span> <span class="o">=</span> <span class="n">xCellSize</span><span class="p">,</span> <span class="n">yRes</span> <span class="o">=</span> <span class="n">yCellSize</span><span class="p">)</span>

    <span class="c1"># clean up</span>
    <span class="n">vrt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># delete the VRT file</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">vrtFullName</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vrtFullName</span><span class="p">)</span>
    <span class="k">return</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.NearestPoint" class="doc doc-heading">
<code class="highlight language-python"><span class="n">NearestPoint</span><span class="p">(</span><span class="n">p1df</span><span class="p">,</span> <span class="n">x1FieldName</span><span class="p">,</span> <span class="n">y1FieldName</span><span class="p">,</span> <span class="n">p2df</span><span class="p">,</span> <span class="n">x2FieldName</span><span class="p">,</span> <span class="n">y2FieldName</span><span class="p">,</span> <span class="n">distFieldName</span><span class="o">=</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">otherColumns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.NearestPoint" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Join two sets of points by nearest distance. The returned data frame will have, in addition to p1df fields, a new distance field (i.e., distFieldName), 
plus other fields (i.e., otherColumns) copied from p2df.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>p1df</code></td>
        <td><code>data frame</code></td>
        <td><p>the first set of points as a pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>x1FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in p1df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y1FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in p1df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>p2df</code></td>
        <td><code>data frame</code></td>
        <td><p>the second set of points as a pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>x2FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in p2df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y2FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name y coordinates in p2df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>distFieldName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the distance field in the returned data frame, default is 'dist'</p></td>
        <td><code>&#39;dist&#39;</code></td>
      </tr>
      <tr>
        <td><code>otherColumns</code></td>
        <td><code>list</code></td>
        <td><p>the names of other fields to be copied from p2df to the returned data frame,default is None</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>      

        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">NearestPoint</span><span class="p">(</span><span class="n">p1df</span><span class="p">,</span> <span class="n">x1FieldName</span><span class="p">,</span> <span class="n">y1FieldName</span><span class="p">,</span> <span class="n">p2df</span><span class="p">,</span> <span class="n">x2FieldName</span><span class="p">,</span> <span class="n">y2FieldName</span><span class="p">,</span> <span class="n">distFieldName</span><span class="o">=</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span><span class="n">otherColumns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Join two sets of points by nearest distance. The returned data frame will have, in addition to p1df fields, a new distance field (i.e., distFieldName), </span>
<span class="sd">        plus other fields (i.e., otherColumns) copied from p2df.</span>

<span class="sd">        Args:</span>
<span class="sd">            p1df (data frame): the first set of points as a pandas DataFrame</span>
<span class="sd">            x1FieldName (str): the field name of y coordinates in p1df</span>
<span class="sd">            y1FieldName (str): the field name of y coordinates in p1df</span>
<span class="sd">            p2df (data frame): the second set of points as a pandas DataFrame</span>
<span class="sd">            x2FieldName (str): the field name of x coordinates in p2df</span>
<span class="sd">            y2FieldName (str): the field name y coordinates in p2df</span>
<span class="sd">            distFieldName (str): the name of the distance field in the returned data frame, default is &#39;dist&#39;</span>
<span class="sd">            otherColumns (list): the names of other fields to be copied from p2df to the returned data frame,default is None</span>
<span class="sd">        Return: </span>
<span class="sd">            data frame: a data frame with the nearest points from p2df for each point in p1df.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># # make sure the input DFs have unique index so that deltaX, deltaY and p2df[&#39;Dist&#39;] = deltaX*deltaX + deltaY*deltaY can work</span>
    <span class="n">p1df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">p2df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Create a temp DF for storing the nearest points from p2df</span>
    <span class="k">if</span> <span class="n">otherColumns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">distFieldName</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">distFieldName</span><span class="p">]</span> <span class="o">+</span> <span class="n">otherColumns</span>
    <span class="n">nearestP2Df</span> <span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="c1"># find the nearest point from p2df for each point in p1df</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">p1df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span> <span class="c1"># itertuples() is the fastest way of iterating a df</span>
        <span class="c1"># find the nearest pt2</span>
        <span class="n">idx</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="s1">&#39;Index&#39;</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">x1FieldName</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">y1FieldName</span><span class="p">))</span>
        <span class="n">deltaX</span> <span class="o">=</span> <span class="n">p2df</span><span class="p">[</span><span class="n">x2FieldName</span><span class="p">]</span><span class="o">-</span><span class="n">x1</span>
        <span class="n">deltaY</span> <span class="o">=</span> <span class="n">p2df</span><span class="p">[</span><span class="n">y2FieldName</span><span class="p">]</span><span class="o">-</span><span class="n">y1</span>
        <span class="c1"># calculate distance to all the points in p2df</span>
        <span class="n">distDf</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span>

        <span class="c1"># get the nearest point&#39;s index and dist</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">distDf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idxp2</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># update dist</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># get additional fields from p2df by index</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">dist</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxp2</span><span class="p">,</span><span class="n">otherColumns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># add the nearest point to the nearest point DF</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">values</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="c1"># nearestP2Df = nearestP2Df.append(t,ignore_index=False)</span>
        <span class="n">nearestP2Df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">nearestP2Df</span><span class="p">,</span><span class="n">t</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># merge p1df points with their nearest points using their index</span>
    <span class="n">p1df</span> <span class="o">=</span> <span class="n">p1df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nearestP2Df</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p1df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.NearestPointInPlace" class="doc doc-heading">
<code class="highlight language-python"><span class="n">NearestPointInPlace</span><span class="p">(</span><span class="n">p1df</span><span class="p">,</span> <span class="n">x1FieldName</span><span class="p">,</span> <span class="n">y1FieldName</span><span class="p">,</span> <span class="n">p2df</span><span class="p">,</span> <span class="n">x2FieldName</span><span class="p">,</span> <span class="n">y2FieldName</span><span class="p">,</span> <span class="n">distFieldName</span><span class="o">=</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">otherColumns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.NearestPointInPlace" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Join two sets of points by nearest distance. p1df will have a new distance field (i.e., distFieldName), plus other fields (i.e., otherColumns) copied from p2df.
Note that this function changes p1df. This is the only difference between this function and NearestPoint()! This is the only difference between this function and NearestPoint()!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>p1df</code></td>
        <td><code>data frame</code></td>
        <td><p>the first set of points as a pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>x1FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in p1df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y1FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in p1df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>p2df</code></td>
        <td><code>data frame</code></td>
        <td><p>the second set of points as a pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>x2FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in p2df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y2FieldName</code></td>
        <td><code>str</code></td>
        <td><p>the field name y coordinates in p2df</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>distFieldName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the distance field in the returned data frame, default is 'dist'</p></td>
        <td><code>&#39;dist&#39;</code></td>
      </tr>
      <tr>
        <td><code>otherColumns</code></td>
        <td><code>list</code></td>
        <td><p>the names of other fields to be copied from p2df to the returned data frame, default is None</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>p1df with the nearest points from p2df.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">NearestPointInPlace</span><span class="p">(</span><span class="n">p1df</span><span class="p">,</span> <span class="n">x1FieldName</span><span class="p">,</span> <span class="n">y1FieldName</span><span class="p">,</span> <span class="n">p2df</span><span class="p">,</span> <span class="n">x2FieldName</span><span class="p">,</span> <span class="n">y2FieldName</span><span class="p">,</span> <span class="n">distFieldName</span><span class="o">=</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">otherColumns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Join two sets of points by nearest distance. p1df will have a new distance field (i.e., distFieldName), plus other fields (i.e., otherColumns) copied from p2df.</span>
<span class="sd">        Note that this function changes p1df. This is the only difference between this function and NearestPoint()! This is the only difference between this function and NearestPoint()!</span>

<span class="sd">        Args:</span>
<span class="sd">            p1df (data frame): the first set of points as a pandas DataFrame</span>
<span class="sd">            x1FieldName (str): the field name of y coordinates in p1df</span>
<span class="sd">            y1FieldName (str): the field name of y coordinates in p1df</span>
<span class="sd">            p2df (data frame): the second set of points as a pandas DataFrame</span>
<span class="sd">            x2FieldName (str): the field name of x coordinates in p2df</span>
<span class="sd">            y2FieldName (str): the field name y coordinates in p2df</span>
<span class="sd">            distFieldName (str): the name of the distance field in the returned data frame, default is &#39;dist&#39;</span>
<span class="sd">            otherColumns (list): the names of other fields to be copied from p2df to the returned data frame, default is None</span>
<span class="sd">        Return:</span>
<span class="sd">            data frame: p1df with the nearest points from p2df.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># # make sure the input DFs have unique index so that deltaX, deltaY and p2df[&#39;Dist&#39;] = deltaX*deltaX + deltaY*deltaY can work</span>
    <span class="n">p1df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">p2df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Create a temp DF for storing the nearest points from p2df</span>
    <span class="k">if</span> <span class="n">otherColumns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">distFieldName</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">distFieldName</span><span class="p">]</span> <span class="o">+</span> <span class="n">otherColumns</span>

    <span class="c1"># find the nearest point from p2df for each point in p1df</span>
    <span class="c1"># find the nearest pt2 for each pt1</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">p1df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> 
        <span class="c1"># find the nearest point in pt2df</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">x1FieldName</span><span class="p">],</span><span class="n">p1df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">y1FieldName</span><span class="p">])</span>
        <span class="n">deltaX</span> <span class="o">=</span> <span class="n">p2df</span><span class="p">[</span><span class="n">x2FieldName</span><span class="p">]</span><span class="o">-</span><span class="n">x1</span>
        <span class="n">deltaY</span> <span class="o">=</span> <span class="n">p2df</span><span class="p">[</span><span class="n">y2FieldName</span><span class="p">]</span><span class="o">-</span><span class="n">y1</span>
        <span class="c1"># calculate distance to all the points in p2df</span>
        <span class="n">distDf</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span>

        <span class="c1"># get the nearest point&#39;s index and dist</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">distDf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idxp2</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># update dist</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># get additional fields from p2df by index</span>
        <span class="n">nearestPt</span> <span class="o">=</span> <span class="n">p2df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxp2</span><span class="p">,</span><span class="n">otherColumns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># add the dist and other fields to p1df</span>
        <span class="n">p1df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">dist</span><span class="p">]</span> <span class="o">+</span> <span class="n">nearestPt</span>

    <span class="k">return</span> <span class="n">p1df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.SnapGauges2Fsps" class="doc doc-heading">
<code class="highlight language-python"><span class="n">SnapGauges2Fsps</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libNames</span><span class="p">,</span> <span class="n">gauges</span><span class="p">,</span> <span class="n">snapDist</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">fspColumns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span> <span class="s1">&#39;FspX&#39;</span><span class="p">,</span> <span class="s1">&#39;FspY&#39;</span><span class="p">,</span> <span class="s1">&#39;FilledElev&#39;</span><span class="p">])</span></code>


<a href="#fldpln.mapping.SnapGauges2Fsps" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Snap gauges to library FSPs. The function will return a data frame with the nearest FSPs for each gauge in each library. 
Note that multiple FSPs from different libraries might be snapped to the same gauge!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are located</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libNames</code></td>
        <td><code>list</code></td>
        <td><p>a list of library names that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gauges</code></td>
        <td><code>str or data frame</code></td>
        <td><p>a text file or a pandas DF of gauges. It must have the columns of 'X' and 'Y' in FSP's coordinate system</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>snapDist</code></td>
        <td><code>float</code></td>
        <td><p>the distance to snap gauges to FSPs, default is 350</p></td>
        <td><code>350</code></td>
      </tr>
      <tr>
        <td><code>gaugeXField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in gauges, default is 'X'</p></td>
        <td><code>&#39;X&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeYField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in gauges, default is 'Y'</p></td>
        <td><code>&#39;Y&#39;</code></td>
      </tr>
      <tr>
        <td><code>fspColumns</code></td>
        <td><code>list</code></td>
        <td><p>the names of FSP columns to be returned, default is ['FspId','FspX','FspY','FilledElev']</p></td>
        <td><code>[&#39;FspId&#39;, &#39;FspX&#39;, &#39;FspY&#39;, &#39;FilledElev&#39;]</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with the nearest FSPs for each gauge in each library.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">SnapGauges2Fsps</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libNames</span><span class="p">,</span><span class="n">gauges</span><span class="p">,</span><span class="n">snapDist</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span><span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="n">fspColumns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Snap gauges to library FSPs. The function will return a data frame with the nearest FSPs for each gauge in each library. </span>
<span class="sd">        Note that multiple FSPs from different libraries might be snapped to the same gauge!</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are located</span>
<span class="sd">            libNames (list): a list of library names that the gauges will be snapped to</span>
<span class="sd">            gauges (str or data frame): a text file or a pandas DF of gauges. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>
<span class="sd">            snapDist (float): the distance to snap gauges to FSPs, default is 350</span>
<span class="sd">            gaugeXField (str): the field name of x coordinates in gauges, default is &#39;X&#39;</span>
<span class="sd">            gaugeYField (str): the field name of y coordinates in gauges, default is &#39;Y&#39;</span>
<span class="sd">            fspColumns (list): the names of FSP columns to be returned, default is [&#39;FspId&#39;,&#39;FspX&#39;,&#39;FspY&#39;,&#39;FilledElev&#39;]</span>
<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with the nearest FSPs for each gauge in each library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges</span><span class="p">,(</span><span class="nb">str</span><span class="p">)):</span>
        <span class="c1"># assume gauges are a text file</span>
        <span class="n">allGaugesDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gauges</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># gauges is a DF</span>
        <span class="n">allGaugesDf</span> <span class="o">=</span> <span class="n">gauges</span>

    <span class="c1"># snape gauges to all the FSPs in each library</span>
    <span class="c1"># initialization</span>
    <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="c1"># snap library by library</span>
    <span class="k">for</span> <span class="n">libName</span> <span class="ow">in</span> <span class="n">libNames</span><span class="p">:</span>
        <span class="c1"># read fsp info csv files</span>
        <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspInfoFileName</span><span class="p">),</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">fspColumns</span><span class="p">]</span>

        <span class="c1"># Find FSP extent + snap distance</span>
        <span class="n">fspMinX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span> <span class="c1"># half cell size?</span>
        <span class="n">fspMaxX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>
        <span class="n">fspMinY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span>
        <span class="n">fspMaxY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>

        <span class="c1"># select the gauges within the FSP extent of the library</span>
        <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">allGaugesDf</span><span class="p">[(</span><span class="n">allGaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">allGaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">allGaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinY</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">allGaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxY</span><span class="p">)]</span>

        <span class="c1"># find the nearest FSP for each gauge</span>
        <span class="n">distFieldName</span> <span class="o">=</span> <span class="s1">&#39;d2NearestFsp&#39;</span>
        <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">NearestPoint</span><span class="p">(</span><span class="n">gaugesDf</span><span class="p">,</span><span class="n">gaugeXField</span><span class="p">,</span><span class="n">gaugeYField</span><span class="p">,</span><span class="n">fspDf</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="n">distFieldName</span><span class="p">,</span><span class="n">fspColumns</span><span class="p">)</span>

        <span class="c1"># select gauges within snap distance</span>
        <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">distFieldName</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">snapDist</span><span class="p">)]</span>
        <span class="c1"># add library name </span>
        <span class="n">gaugesDf</span><span class="p">[</span><span class="s1">&#39;lib_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">libName</span>

        <span class="k">if</span> <span class="n">snappedGauges</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">gaugesDf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">snappedGauges</span><span class="p">,</span><span class="n">gaugesDf</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">snappedGauges</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.SnapGauges2FspsBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">SnapGauges2FspsBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gaugesDf</span><span class="p">,</span> <span class="n">snapDist</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span> <span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.SnapGauges2FspsBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Snap gauges to library FSPs on Microsoft Planetary Computer (MPC) using Azure Blob Storage. The function has NOT been checked yet!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a blob service client</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugesDf</code></td>
        <td><code>data frame</code></td>
        <td><p>a pandas DF of gauges. It must have the columns of 'X' and 'Y' in FSP's coordinate system</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>snapDist</code></td>
        <td><code>float</code></td>
        <td><p>the distance to snap gauges to FSPs, default is 350</p></td>
        <td><code>350</code></td>
      </tr>
      <tr>
        <td><code>gaugeIdField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of gauge IDs in gauges, default is 'GaugeLID'</p></td>
        <td><code>&#39;GaugeLID&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeXField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in gauges, default is 'X'</p></td>
        <td><code>&#39;X&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeYField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in gauges, default is 'Y'</p></td>
        <td><code>&#39;Y&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with the nearest FSPs for each gauge in the library.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">SnapGauges2FspsBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gaugesDf</span><span class="p">,</span><span class="n">snapDist</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span><span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Snap gauges to library FSPs on Microsoft Planetary Computer (MPC) using Azure Blob Storage. The function has NOT been checked yet!</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a blob service client</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gaugesDf (data frame): a pandas DF of gauges. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>
<span class="sd">            snapDist (float): the distance to snap gauges to FSPs, default is 350</span>
<span class="sd">            gaugeIdField (str): the field name of gauge IDs in gauges, default is &#39;GaugeLID&#39;</span>
<span class="sd">            gaugeXField (str): the field name of x coordinates in gauges, default is &#39;X&#39;</span>
<span class="sd">            gaugeYField (str): the field name of y coordinates in gauges, default is &#39;Y&#39;</span>
<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with the nearest FSPs for each gauge in the library.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1"># gauges -- a pandas DF. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>

    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>

    <span class="c1"># read fsp info csv files</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">fspInfoFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>

    <span class="c1"># Find FSP&#39;s border extent + snap distance</span>
    <span class="n">fspMinX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span> <span class="c1"># half cell size?</span>
    <span class="n">fspMaxX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>
    <span class="n">fspMinY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span>
    <span class="n">fspMaxY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>

    <span class="c1"># select the gauges within the extent</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinY</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxY</span><span class="p">)]</span>

    <span class="c1"># Create a temp DF for nearest FSPs</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">gaugeIdField</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FspFilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span>
    <span class="n">nearestFspDf</span> <span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="c1"># find the nearest FSP for each gauge</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># itertuples() is the fastest way of iterating a df</span>
        <span class="c1"># find the nearest FSP</span>
        <span class="n">glid</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeXField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeYField</span><span class="p">))</span>
        <span class="n">deltaX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">x</span>
        <span class="n">deltaY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">y</span>
        <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span>
        <span class="n">nearestFsp</span> <span class="o">=</span> <span class="n">fspDf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Dist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span> <span class="o">=</span> <span class="n">nearestFsp</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="c1"># add the nearest FSP to the gauge DF</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">glid</span><span class="p">,</span><span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span><span class="p">]],</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="c1"># nearestFspDf = nearestFspDf.append(t,ignore_index=True)</span>
        <span class="n">nearestFspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">nearestFspDf</span><span class="p">,</span><span class="n">t</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># merge gauge and their nearest FSPs</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nearestFspDf</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">gaugeIdField</span><span class="p">)</span>
    <span class="c1"># select gauges within snap distance</span>
    <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">snapDist</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">snappedGauges</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.SnapGaugesToFsps" class="doc doc-heading">
<code class="highlight language-python"><span class="n">SnapGaugesToFsps</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gauges</span><span class="p">,</span> <span class="n">snapDist</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span> <span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.SnapGaugesToFsps" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Snap gauges to library FSPs. The function will return a data frame with the snapped gauges only.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are located</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gauges</code></td>
        <td><code>str or data frame</code></td>
        <td><p>a text file or a pandas data frame of gauges. It must have the columns of 'X' and 'Y' in FSP's coordinate system</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>snapDist</code></td>
        <td><code>float</code></td>
        <td><p>the distance to snap gauges to FSPs, default is 250</p></td>
        <td><code>250</code></td>
      </tr>
      <tr>
        <td><code>gaugeIdField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of gauge IDs in gauges, default is 'GaugeLID'</p></td>
        <td><code>&#39;GaugeLID&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeXField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in gauges, default is 'X'</p></td>
        <td><code>&#39;X&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeYField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in gauges, default is 'Y'</p></td>
        <td><code>&#39;Y&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with the snapped gauges only.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">SnapGaugesToFsps</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gauges</span><span class="p">,</span><span class="n">snapDist</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span><span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Snap gauges to library FSPs. The function will return a data frame with the snapped gauges only.</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are located</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gauges (str or data frame): a text file or a pandas data frame of gauges. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>
<span class="sd">            snapDist (float): the distance to snap gauges to FSPs, default is 250</span>
<span class="sd">            gaugeIdField (str): the field name of gauge IDs in gauges, default is &#39;GaugeLID&#39;</span>
<span class="sd">            gaugeXField (str): the field name of x coordinates in gauges, default is &#39;X&#39;</span>
<span class="sd">            gaugeYField (str): the field name of y coordinates in gauges, default is &#39;Y&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with the snapped gauges only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1"># gauges -- can be a pandas DF or a text file. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges</span><span class="p">,(</span><span class="nb">str</span><span class="p">)):</span>
        <span class="c1"># assume gauges are a text file</span>
        <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gauges</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># gauges is a DF</span>
        <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gauges</span>

    <span class="c1"># read fsp info csv files</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspInfoFileName</span><span class="p">),</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>

    <span class="c1"># Find FSP&#39;s border extent + snap distance</span>
    <span class="n">fspMinX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span> <span class="c1"># half cell size?</span>
    <span class="n">fspMaxX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>
    <span class="n">fspMinY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span>
    <span class="n">fspMaxY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>

    <span class="c1"># select the gauges within the extent</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinY</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxY</span><span class="p">)]</span>

    <span class="c1"># Create a temp DF for nearest FSPs</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">gaugeIdField</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FspFilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span>
    <span class="n">nearestFspDf</span> <span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="c1"># find the nearest FSP for each gauge</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># itertuples() is the fastest way of iterating a df</span>
        <span class="c1"># find the nearest FSP</span>
        <span class="n">glid</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeXField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeYField</span><span class="p">))</span>
        <span class="n">deltaX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">x</span>
        <span class="n">deltaY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">y</span>
        <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span>
        <span class="n">nearestFsp</span> <span class="o">=</span> <span class="n">fspDf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Dist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span> <span class="o">=</span> <span class="n">nearestFsp</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="c1"># add the nearest FSP to the gauge DF</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">glid</span><span class="p">,</span><span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span><span class="p">]],</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="c1"># nearestFspDf = nearestFspDf.append(t,ignore_index=True)</span>
        <span class="n">nearestFspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">nearestFspDf</span><span class="p">,</span><span class="n">t</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># merge gauge and their nearest FSPs</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nearestFspDf</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">gaugeIdField</span><span class="p">)</span>
    <span class="c1"># select gauges within snap distance</span>
    <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">snapDist</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">snappedGauges</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.SnapGaugesToFspsBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">SnapGaugesToFspsBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">gaugesDf</span><span class="p">,</span> <span class="n">snapDist</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span> <span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span></code>


<a href="#fldpln.mapping.SnapGaugesToFspsBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Snap gauges to library FSPs on Microsoft Planetary Computer (MPC) using Azure Blob Storage. The function is has NOT been checked yet!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a blob service client</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library that the gauges will be snapped to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gaugesDf</code></td>
        <td><code>data frame</code></td>
        <td><p>a pandas DF of gauges. It must have the columns of 'X' and 'Y' in FSP's coordinate system</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>snapDist</code></td>
        <td><code>float</code></td>
        <td><p>the distance to snap gauges to FSPs, default is 250</p></td>
        <td><code>250</code></td>
      </tr>
      <tr>
        <td><code>gaugeIdField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of gauge IDs in gauges, default is 'GaugeLID'</p></td>
        <td><code>&#39;GaugeLID&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeXField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of x coordinates in gauges, default is 'X'</p></td>
        <td><code>&#39;X&#39;</code></td>
      </tr>
      <tr>
        <td><code>gaugeYField</code></td>
        <td><code>str</code></td>
        <td><p>the field name of y coordinates in gauges, default is 'Y'</p></td>
        <td><code>&#39;Y&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data frame</code></td>
      <td><p>a data frame with the snapped gauges only.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">SnapGaugesToFspsBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">gaugesDf</span><span class="p">,</span><span class="n">snapDist</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="o">=</span><span class="s1">&#39;GaugeLID&#39;</span><span class="p">,</span><span class="n">gaugeXField</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="n">gaugeYField</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Snap gauges to library FSPs on Microsoft Planetary Computer (MPC) using Azure Blob Storage. The function is has NOT been checked yet!</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a blob service client</span>
<span class="sd">            libName (str): the name of the library that the gauges will be snapped to</span>
<span class="sd">            gaugesDf (data frame): a pandas DF of gauges. It must have the columns of &#39;X&#39; and &#39;Y&#39; in FSP&#39;s coordinate system</span>
<span class="sd">            snapDist (float): the distance to snap gauges to FSPs, default is 250</span>
<span class="sd">            gaugeIdField (str): the field name of gauge IDs in gauges, default is &#39;GaugeLID&#39;</span>
<span class="sd">            gaugeXField (str): the field name of x coordinates in gauges, default is &#39;X&#39;</span>
<span class="sd">            gaugeYField (str): the field name of y coordinates in gauges, default is &#39;Y&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            data frame: a data frame with the snapped gauges only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>

    <span class="c1"># read fsp info csv files</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">fspInfoFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">fspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">]]</span>

    <span class="c1"># Find FSP&#39;s border extent + snap distance</span>
    <span class="n">fspMinX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span> <span class="c1"># half cell size?</span>
    <span class="n">fspMaxX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>
    <span class="n">fspMinY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">snapDist</span>
    <span class="n">fspMaxY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">snapDist</span>

    <span class="c1"># select the gauges within the extent</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeXField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">fspMinY</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="n">gaugeYField</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">fspMaxY</span><span class="p">)]</span>

    <span class="c1"># Create a temp DF for nearest FSPs</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">gaugeIdField</span><span class="p">,</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FspFilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span>
    <span class="n">nearestFspDf</span> <span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="c1"># find the nearest FSP for each gauge</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># itertuples() is the fastest way of iterating a df</span>
        <span class="c1"># find the nearest FSP</span>
        <span class="n">glid</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeIdField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeXField</span><span class="p">),</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">gaugeYField</span><span class="p">))</span>
        <span class="n">deltaX</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspX&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">x</span>
        <span class="n">deltaY</span> <span class="o">=</span> <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;FspY&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">y</span>
        <span class="n">fspDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span>
        <span class="n">nearestFsp</span> <span class="o">=</span> <span class="n">fspDf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Dist&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span> <span class="o">=</span> <span class="n">nearestFsp</span><span class="p">[[</span><span class="s1">&#39;FspX&#39;</span><span class="p">,</span><span class="s1">&#39;FspY&#39;</span><span class="p">,</span><span class="s1">&#39;FilledElev&#39;</span><span class="p">,</span><span class="s1">&#39;Dist&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="c1"># add the nearest FSP to the gauge DF</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">glid</span><span class="p">,</span><span class="n">fspX</span><span class="p">,</span><span class="n">fspY</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">dist</span><span class="p">]],</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="c1"># nearestFspDf = nearestFspDf.append(t,ignore_index=True)</span>
        <span class="n">nearestFspDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">nearestFspDf</span><span class="p">,</span><span class="n">t</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># merge gauge and their nearest FSPs</span>
    <span class="n">gaugesDf</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nearestFspDf</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">gaugeIdField</span><span class="p">)</span>
    <span class="c1"># select gauges within snap distance</span>
    <span class="n">snappedGauges</span> <span class="o">=</span> <span class="n">gaugesDf</span><span class="p">[(</span><span class="n">gaugesDf</span><span class="p">[</span><span class="s1">&#39;Dist&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">snapDist</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">snappedGauges</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.TileFspFppRelations2Array" class="doc doc-heading">
<code class="highlight language-python"><span class="n">TileFspFppRelations2Array</span><span class="p">(</span><span class="n">fspFppRels</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noData</span><span class="o">=-</span><span class="mi">9999</span><span class="p">)</span></code>


<a href="#fldpln.mapping.TileFspFppRelations2Array" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Turn a dataframe of FSP-FPP relations to a 2D array of flood depth. 
The minimum bounding extent of the FPPs in the relations is always used when create the map for the tile!</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>fspFppRels</code></td>
        <td><code>data frame</code></td>
        <td><p>a dataframe of FSP-FPP relations which have the columns of ["FspId", "FppCol", "FppRow", "Dtf", "FilledDepth"] from a tile</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fppExtent</code></td>
        <td><code>list</code></td>
        <td><p>a list of [minX, maxX, minY, maxY], FPP's external extent of the tile and is also used to locate FPP's columns and rows in map coordinate</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cellSize</code></td>
        <td><code>float</code></td>
        <td><p>the cell size of the raster</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>noData</code></td>
        <td><code>int</code></td>
        <td><p>the no data value, default is -9999</p></td>
        <td><code>-9999</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>a tuple of the np array as the map, the no data value, the minimum X value, and the minimum Y value</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">TileFspFppRelations2Array</span><span class="p">(</span><span class="n">fspFppRels</span><span class="p">,</span> <span class="n">fppExtent</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noData</span><span class="o">=-</span><span class="mi">9999</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Turn a dataframe of FSP-FPP relations to a 2D array of flood depth. </span>
<span class="sd">        The minimum bounding extent of the FPPs in the relations is always used when create the map for the tile!</span>

<span class="sd">        Args:</span>
<span class="sd">            fspFppRels (data frame): a dataframe of FSP-FPP relations which have the columns of [&quot;FspId&quot;, &quot;FppCol&quot;, &quot;FppRow&quot;, &quot;Dtf&quot;, &quot;FilledDepth&quot;] from a tile</span>
<span class="sd">            fppExtent (list): a list of [minX, maxX, minY, maxY], FPP&#39;s external extent of the tile and is also used to locate FPP&#39;s columns and rows in map coordinate</span>
<span class="sd">            cellSize (float): the cell size of the raster</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None</span>
<span class="sd">            noData (int): the no data value, default is -9999</span>

<span class="sd">        Return:</span>
<span class="sd">            tuple: a tuple of the np array as the map, the no data value, the minimum X value, and the minimum Y value</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tdf</span> <span class="o">=</span> <span class="n">fspFppRels</span>
    <span class="c1"># print(&#39;Number of FSP-FPP relations:&#39;, len(tdf))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tdf</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no FPP needs to be mapping</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Limit the FPPs in the tile to the AOI extent when provided</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">aoiExtent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Note that the aoiExtent intersects with the tile, otherwise the tile won&#39;t be selected for mapping!</span>
        <span class="n">fppMinX</span><span class="p">,</span><span class="n">fppMaxX</span><span class="p">,</span><span class="n">fppMinY</span><span class="p">,</span><span class="n">fppMaxY</span> <span class="o">=</span> <span class="n">fppExtent</span>
        <span class="n">aoiMinX</span><span class="p">,</span><span class="n">aoiMaxX</span><span class="p">,</span><span class="n">aoiMinY</span><span class="p">,</span><span class="n">aoiMaxY</span> <span class="o">=</span> <span class="n">aoiExtent</span>
        <span class="c1"># calculate new FPP extent within the fppExtent</span>
        <span class="n">newFppMinX</span><span class="p">,</span> <span class="n">newFppMinY</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fppMinX</span><span class="p">,</span><span class="n">aoiMinX</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">fppMinY</span><span class="p">,</span><span class="n">aoiMinY</span><span class="p">)</span>
        <span class="n">newFppMaxX</span><span class="p">,</span> <span class="n">newFppMaxY</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fppMaxX</span><span class="p">,</span><span class="n">aoiMaxX</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">fppMaxY</span><span class="p">,</span><span class="n">aoiMaxY</span><span class="p">)</span>
        <span class="c1"># calculate FPP col &amp; row extent for the new FPP extent</span>
        <span class="n">minFppCol</span><span class="p">,</span><span class="n">maxFppCol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">newFppMinX</span><span class="o">-</span><span class="n">fppMinX</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">newFppMaxX</span><span class="o">-</span><span class="n">fppMinX</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">minFppRow</span><span class="p">,</span><span class="n">maxFppRow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">fppMaxY</span><span class="o">-</span><span class="n">newFppMaxY</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">fppMaxY</span><span class="o">-</span><span class="n">newFppMinY</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="c1"># select the FPPs within the the new fppExtent based on FppCol &amp; FppRow</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minFppCol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxFppCol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minFppRow</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxFppRow</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># tell pandas we want a copy to avoid &quot;SettingWithCopyWarning&quot; in line 459, 465 </span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tdf</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># no FPP needs to be mapping</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1">#</span>
    <span class="c1"># Calculate pixel values at each FPP based on the types of fspDof: &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, &#39;Depression&#39;, a constant DOF, and a list of DOF</span>
    <span class="c1"># Pixel value at each FPP is saved in the &#39;Dtf&#39; column.</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;MinDtf&#39;</span><span class="p">:</span>
        <span class="c1"># no FSP DOF is provide, map the minimum DTF at FPPs</span>
        <span class="c1"># print(&#39;Map the minimum DTF ...&#39;)</span>
        <span class="c1"># calculate the minimum DTF at each FPP</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span> <span class="s1">&#39;FppRow&#39;</span><span class="p">],</span><span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;Dtf&#39;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">})</span> <span class="c1">#,MaxDtf = (&#39;Dtf&#39;, max))</span>
        <span class="c1"># print(tdf)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;NumOfFsps&#39;</span><span class="p">:</span>
        <span class="c1"># no FSP DOF is provide, map the number of FSPs associated with each FPP (neighborhood size of each FPP)</span>
        <span class="c1"># print(&#39;Map the number of FSPs associated with each FPP ...&#39;)</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span> <span class="s1">&#39;FppRow&#39;</span><span class="p">],</span><span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;Dtf&#39;</span><span class="p">:</span><span class="s1">&#39;count&#39;</span><span class="p">})</span> <span class="c1">#size() # count the # of FSPs associated with each FPP</span>
        <span class="c1"># tdf.rename(columns={&#39;size&#39;:&#39;Depth&#39;},inplace=True) # inplace changing column name</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;Depression&#39;</span><span class="p">:</span>
        <span class="c1"># print(&#39;Map depression depth ...&#39;)</span>
        <span class="c1"># assign &#39;Dtf&#39; to filled drpression</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FilledDepth&#39;</span><span class="p">]</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span> <span class="s1">&#39;FppRow&#39;</span><span class="p">],</span><span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;Dtf&#39;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">})</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span> <span class="c1"># constant stage for all the FSPs</span>
        <span class="c1"># all the FSPs in the tile have the same DOF</span>
        <span class="c1"># print(f&quot;Map a constant FSP DOF of {fspDof} ...&quot;)</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fspDof</span><span class="p">)</span> <span class="o">-</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span> <span class="s1">&#39;FppRow&#39;</span><span class="p">],</span><span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;Dtf&#39;</span><span class="p">:</span><span class="s1">&#39;max&#39;</span><span class="p">,</span><span class="s1">&#39;FilledDepth&#39;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">})</span>
        <span class="c1"># add the depth of filled drpression</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FilledDepth&#39;</span><span class="p">]</span>

        <span class="c1"># code used to find negative flood depth for library &#39;midkan&#39;</span>
        <span class="c1"># t = tdf[&#39;Dtf&#39;]&lt;0</span>
        <span class="c1"># if t.any():</span>
        <span class="c1">#     print(&#39;Negative DTF!&#39;)</span>

    <span class="c1"># Map the tile with a FSP DOF df</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># print(&#39;Map with a list of FSPs with DOFs ...&#39;)</span>

        <span class="c1"># Only keep those relations whose DTF is less than or equal to the max interpolated DOF. </span>
        <span class="c1"># This significantly saves memory and time when merge the relations with the DOFs!</span>
        <span class="n">maxDof</span> <span class="o">=</span> <span class="n">fspDof</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDof</span><span class="p">]</span> <span class="c1"># tdf.drop(tdf[tdf[&#39;Dtf&#39;]&lt;=0].index, inplace=True) # saves memory than tdf = tdf[tdf[&#39;Dtf&#39;] &gt; 0]?</span>
        <span class="c1"># print(&#39;Number of relations to be mapped: &#39;,len(tdf))</span>

        <span class="c1"># set FSP DOF column data types to speed merge</span>
        <span class="n">fspDof</span> <span class="o">=</span> <span class="n">fspDof</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;FspId&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span><span class="s2">&quot;Dof&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">},</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># create index to speed up merge</span>
        <span class="c1"># tdf.astype(np.float32,copy=False).set_index(keys=[&#39;FspX&#39;,&#39;FspY&#39;],inplace=True)</span>
        <span class="c1"># fspDof.astype(np.float32,copy=False).set_index(keys=[&#39;FspX&#39;,&#39;FspY&#39;],inplace=True)</span>
        <span class="c1"># tdf = pd.merge(tdf, fspDof, how=&#39;inner&#39;, left_index=True,right_index=True)</span>

        <span class="c1"># map the FPPs whose FSPs&#39; DOF &gt; the MinDOF</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tdf</span><span class="p">,</span> <span class="n">fspDof</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">])</span> <span class="c1">#.astype(np.float32,copy=False)</span>

        <span class="c1"># calculate DTF</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span>
        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># tdf.drop(tdf[tdf[&#39;Dtf&#39;]&lt;=0].index, inplace=True) # saves memory than tdf = tdf[tdf[&#39;Dtf&#39;] &gt; 0]?</span>

        <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span> <span class="s1">&#39;FppRow&#39;</span><span class="p">],</span><span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;Dtf&#39;</span><span class="p">:</span><span class="s1">&#39;max&#39;</span><span class="p">,</span><span class="s1">&#39;FilledDepth&#39;</span><span class="p">:</span><span class="s1">&#39;first&#39;</span><span class="p">})</span> <span class="c1">#Depth = (&#39;Dtf&#39;, max),FilledDepth=(&#39;FilledDepth&#39;,first))</span>
        <span class="c1"># print(tdf)</span>
        <span class="c1"># add the depth of filled drpression</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FilledDepth&#39;</span><span class="p">]</span>
        <span class="c1"># drop &#39;FilledDepth&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported fspDof type </span><span class="si">{</span><span class="n">fspDof</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="c1">#</span>
    <span class="c1"># Turn relations into 2D array</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tdf</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no FPP needs to be mapping</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># drop off not-used columns in the DF</span>
    <span class="n">tdf</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">,</span><span class="s1">&#39;FppRow&#39;</span><span class="p">,</span><span class="s1">&#39;Dtf&#39;</span><span class="p">]]</span>
    <span class="c1"># tdf.drop(columns=[&#39;FilledDepth&#39;],axis=1,inplace=True)</span>

    <span class="c1"># Determine the minimum map extent to speed up the mapping</span>
    <span class="c1"># original map extent is the FPP&#39;s extent</span>
    <span class="n">mapMinX</span><span class="p">,</span><span class="n">mapMaxX</span><span class="p">,</span><span class="n">mapMinY</span><span class="p">,</span><span class="n">mapMaxY</span> <span class="o">=</span> <span class="n">fppExtent</span>

    <span class="c1"># further reduce map extent if FPP extent is reduced</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">aoiExtent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># further reduce the map extent with the FPPs </span>
        <span class="n">mapMinCol</span><span class="p">,</span><span class="n">mapMaxCol</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">mapMinRow</span><span class="p">,</span><span class="n">mapMaxRow</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="c1"># shift FPP&#39;s cols and rows</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppCol&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">mapMinCol</span>
        <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;FppRow&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">mapMinRow</span>
        <span class="c1"># calculate map&#39;s new extent</span>
        <span class="n">mapMaxX</span> <span class="o">=</span> <span class="n">mapMinX</span> <span class="o">+</span> <span class="p">(</span><span class="n">mapMaxCol</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cellSize</span> <span class="c1"># this line MUST before the next line as the next line changes mapMinX!</span>
        <span class="n">mapMinX</span> <span class="o">=</span> <span class="n">mapMinX</span> <span class="o">+</span> <span class="n">mapMinCol</span><span class="o">*</span><span class="n">cellSize</span>
        <span class="n">mapMinY</span> <span class="o">=</span> <span class="n">mapMaxY</span> <span class="o">-</span> <span class="p">(</span><span class="n">mapMaxRow</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cellSize</span> <span class="c1"># this line MUST before the next line as the next line changes mapMaxY!</span>
        <span class="n">mapMaxY</span> <span class="o">=</span> <span class="n">mapMaxY</span> <span class="o">-</span> <span class="n">mapMinRow</span><span class="o">*</span><span class="n">cellSize</span>

    <span class="c1"># print(&#39;Map extent (minX, maxX, minY, maxY) :&#39;,(mapMinX, mapMaxX, mapMinY, mapMaxY))</span>
    <span class="c1"># Calculate map rows and columns</span>
    <span class="n">tCols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mapMaxX</span><span class="o">-</span><span class="n">mapMinX</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">))</span>
    <span class="n">tRows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mapMaxY</span><span class="o">-</span><span class="n">mapMinY</span><span class="p">)</span><span class="o">/</span><span class="n">cellSize</span><span class="p">))</span>
    <span class="c1"># print(f&#39;Turn FSP-FPP relations to a 2D array of {tRows, tCols} ...&#39;)</span>

    <span class="c1"># Initialize the array for saving as a raster</span>
    <span class="n">dtfArray</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">tRows</span><span class="p">,</span><span class="n">tCols</span><span class="p">),</span><span class="n">fill_value</span><span class="o">=</span><span class="n">noData</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># # update the array with FPP&#39;s DTF</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">idy</span><span class="p">,</span><span class="n">dtf</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># itertuples() is the fastest way of iterating a df</span>
        <span class="c1"># idx,idy,dtf = (getattr(row,&#39;FppCol&#39;),getattr(row,&#39;FppRow&#39;),getattr(row,&#39;Dtf&#39;)) </span>
        <span class="n">dtfArray</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtf</span>

    <span class="k">return</span> <span class="n">dtfArray</span><span class="p">,</span> <span class="n">noData</span><span class="p">,</span> <span class="n">mapMinX</span><span class="p">,</span> <span class="n">mapMaxY</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.Tiles2Map" class="doc doc-heading">
<code class="highlight language-python"><span class="n">Tiles2Map</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.Tiles2Map" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Decide the tiles need to be mapped for the library.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libFolder</code></td>
        <td><code>str</code></td>
        <td><p>the folder where the libraries are stored</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>a list of tile IDs, a list of tile FPP extents</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">Tiles2Map</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Decide the tiles need to be mapped for the library.</span>

<span class="sd">        Args:</span>
<span class="sd">            libFolder (str): the folder where the libraries are stored</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None.</span>

<span class="sd">        Return:</span>
<span class="sd">            tuple: a list of tile IDs, a list of tile FPP extents</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Read in the fsp-tile index and tile index files for selecting tiles for mapping</span>
    <span class="c1">#</span>
    <span class="c1"># read in fsp-tile index file to select the tiles for mapping</span>
    <span class="n">fspIdxFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspTileIndexFileName</span><span class="p">)</span>
    <span class="n">fspIdxDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fspIdxFile</span><span class="p">)</span>
    <span class="c1"># print(fspIdxDf)</span>

    <span class="c1"># tile index file stores tile and FPP extents for the tile</span>
    <span class="n">tileIdxFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">libFolder</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">tileIndexFileName</span><span class="p">)</span>
    <span class="n">tileIdxDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">tileIdxFile</span><span class="p">)</span>
    <span class="c1"># print(tileIdxDf)</span>

    <span class="c1">#</span>
    <span class="c1"># Select the tiles for mapping based on the FSPs and fsp-tile index</span>
    <span class="c1">#</span>
    <span class="c1"># print(&#39;Select the tiles need to be mapped ...&#39;)</span>
    <span class="c1"># for &#39;MinDtf&#39;, &#39;NumOfFsps&#39; and &#39;Depression&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;MinDtf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;NumOfFsps&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;Depression&#39;</span><span class="p">):</span>
        <span class="c1"># map all the tiles</span>
        <span class="c1"># fspTiles = fspIdxDf[&#39;TileId&#39;].drop_duplicates().sort_values().tolist()</span>
        <span class="c1"># use tileIdxDf is faster!</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># same as: fspTiles = tileIdxDf[&#39;TileId&#39;].sort_values().to_list()</span>

    <span class="c1"># for constant FSP DOF</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span> <span class="c1"># constant stage for all the FSPs</span>
        <span class="c1"># find which tiles need to be mapped</span>
        <span class="c1"># select those tiles whose FSP&#39;s DOF &gt; MinDtf</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspIdxDf</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">fspDof</span><span class="p">)</span><span class="o">&gt;</span><span class="n">fspIdxDf</span><span class="p">[</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">]]</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># find the tiles need to be mapped</span>
        <span class="c1"># fspTiles = fspTiles[&#39;TileId&#39;].unique()</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># for a dataframe of FSPs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># find which tiles need to be mapped</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fspIdxDf</span><span class="p">,</span> <span class="n">fspDof</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">])</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># select those where DOF &gt; minDtf</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">]]</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># find the tiles need to be mapped</span>
        <span class="c1"># fspTiles = fspTiles[&#39;TileId&#39;].unique()</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported fspDof type </span><span class="si">{</span><span class="n">fspDof</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># tiles selected based on the FSPs</span>
    <span class="c1"># print(&#39;Tiles selected based on FSPs: &#39;, fspTiles)</span>

    <span class="c1"># further limit the tiles to those that intersect with the AOI extent</span>
    <span class="k">if</span> <span class="n">aoiExtent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tiles</span> <span class="o">=</span> <span class="n">fspTiles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># select the tiles intersecting AOI extent based on the FPPs&#39; extent of the tile</span>
        <span class="n">aoiMinX</span><span class="p">,</span><span class="n">aoiMaxX</span><span class="p">,</span><span class="n">aoiMinY</span><span class="p">,</span><span class="n">aoiMaxY</span> <span class="o">=</span> <span class="n">aoiExtent</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="o">~</span><span class="p">((</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;FppMinX&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">aoiMaxX</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;FppMaxX&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">aoiMinX</span><span class="p">))]</span> <span class="c1"># rectangles are NOT on left or right of each other</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">aoiTiles</span><span class="p">[</span><span class="o">~</span><span class="p">((</span><span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;FppMinY&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">aoiMaxY</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;FppMaxY&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">aoiMinY</span><span class="p">))]</span> <span class="c1"># rectangles are NOT on top or bottom of each other</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles selected based on AOI extent: &#39;</span><span class="p">,</span> <span class="n">aoiTiles</span><span class="p">)</span>
        <span class="c1"># intersect the lists</span>
        <span class="n">tiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fspTiles</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">aoiTiles</span><span class="p">))</span>

    <span class="c1"># tiles selected</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># print(&#39;No tile needs to be mapped!&#39;)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get each tile&#39;s fppExtent</span>
        <span class="n">fppExtents</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
            <span class="n">fppExtent</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">tid</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,[</span><span class="s1">&#39;FppMinX&#39;</span><span class="p">,</span><span class="s1">&#39;FppMaxX&#39;</span><span class="p">,</span><span class="s1">&#39;FppMinY&#39;</span><span class="p">,</span><span class="s1">&#39;FppMaxY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">fppExtents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fppExtent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tiles</span><span class="p">,</span><span class="n">fppExtents</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="fldpln.mapping.Tiles2MapBlob" class="doc doc-heading">
<code class="highlight language-python"><span class="n">Tiles2MapBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span> <span class="n">libName</span><span class="p">,</span> <span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span> <span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#fldpln.mapping.Tiles2MapBlob" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Decide the tiles need to be mapped for the library on Microsoft Planetary Computer using Azure Blob Storage.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>libBlobSerClient</code></td>
        <td><code>BlobServiceClient</code></td>
        <td><p>a BlobServiceClient object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>libName</code></td>
        <td><code>str</code></td>
        <td><p>the name of the library</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fspDof</code></td>
        <td><code>str, float, or data frame</code></td>
        <td><p>the FSP DOF for mapping flood depth. default is 'MinDtf'.
If it's a string, it can be 'MinDtf', 'NumOfFsps', or 'Depression'.
If it's a float, it's a constant stage for all the FSPs.
If it's a data frame, it's a data frame of FSPs with DOF.</p></td>
        <td><code>&#39;MinDtf&#39;</code></td>
      </tr>
      <tr>
        <td><code>aoiExtent</code></td>
        <td><code>list</code></td>
        <td><p>the extent of the area of interest [minX,maxX,minY,maxY]. default is None.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>a list of tile IDs, a list of tile FPP extents</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>fldpln/mapping.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">Tiles2MapBlob</span><span class="p">(</span><span class="n">libBlobSerClient</span><span class="p">,</span><span class="n">libName</span><span class="p">,</span><span class="n">fspDof</span><span class="o">=</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">,</span><span class="n">aoiExtent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Decide the tiles need to be mapped for the library on Microsoft Planetary Computer using Azure Blob Storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            libBlobSerClient (BlobServiceClient): a BlobServiceClient object</span>
<span class="sd">            libName (str): the name of the library</span>
<span class="sd">            fspDof (str, float, or data frame): the FSP DOF for mapping flood depth. default is &#39;MinDtf&#39;.</span>
<span class="sd">                If it&#39;s a string, it can be &#39;MinDtf&#39;, &#39;NumOfFsps&#39;, or &#39;Depression&#39;.</span>
<span class="sd">                If it&#39;s a float, it&#39;s a constant stage for all the FSPs.</span>
<span class="sd">                If it&#39;s a data frame, it&#39;s a data frame of FSPs with DOF.</span>
<span class="sd">            aoiExtent (list): the extent of the area of interest [minX,maxX,minY,maxY]. default is None.</span>

<span class="sd">        Return:</span>
<span class="sd">            tuple: a list of tile IDs, a list of tile FPP extents</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Read in the fsp-tile index and tile index files for selecting tiles for ampping</span>
    <span class="c1">#</span>
    <span class="c1"># create a container client, assuming the container already exists</span>
    <span class="n">container_client</span> <span class="o">=</span> <span class="n">libBlobSerClient</span><span class="o">.</span><span class="n">get_container_client</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">libName</span><span class="p">)</span>

    <span class="c1"># read in fsp-tile index file to select the tiles for mapping </span>
    <span class="c1"># get blob client</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">fspTileIndexFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">fspIdxDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># print(fspIdxDf)</span>

    <span class="c1"># tile index file stores tile and FPP extents for the tile</span>
    <span class="c1"># get blob client</span>
    <span class="n">blob_client</span> <span class="o">=</span> <span class="n">container_client</span><span class="o">.</span><span class="n">get_blob_client</span><span class="p">(</span><span class="n">tileIndexFileName</span><span class="p">)</span>
    <span class="c1"># create a SAS token</span>
    <span class="n">sas_token</span> <span class="o">=</span> <span class="n">azure</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">generate_blob_sas</span><span class="p">(</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">account_name</span><span class="p">,</span>
        <span class="n">container_client</span><span class="o">.</span><span class="n">container_name</span><span class="p">,</span>
        <span class="n">blob_client</span><span class="o">.</span><span class="n">blob_name</span><span class="p">,</span>
        <span class="n">account_key</span><span class="o">=</span><span class="n">container_client</span><span class="o">.</span><span class="n">credential</span><span class="o">.</span><span class="n">account_key</span><span class="p">,</span>
        <span class="n">permission</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># construct the URL</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">blob_client</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;?&quot;</span> <span class="o">+</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote_plus</span><span class="p">(</span><span class="n">sas_token</span><span class="p">)</span>
    <span class="c1"># read the blob</span>
    <span class="n">tileIdxDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># print(tileIdxDf)</span>

    <span class="c1">#</span>
    <span class="c1"># Select the tiles for mapping based on the FSPs and fsp-tile index</span>
    <span class="c1">#</span>
    <span class="c1"># print(&#39;Select the tiles need to be mapped ...&#39;)</span>
    <span class="c1"># for &#39;MinDtf&#39;, &#39;NumOfFsps&#39; and &#39;Depression&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;MinDtf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;NumOfFsps&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,(</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="n">fspDof</span> <span class="o">==</span> <span class="s1">&#39;Depression&#39;</span><span class="p">):</span>
        <span class="c1"># map all the tiles</span>
        <span class="c1"># fspTiles = fspIdxDf[&#39;TileId&#39;].drop_duplicates().sort_values().tolist()</span>
        <span class="c1"># use tileIdxDf is faster!</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># same as: fspTiles = tileIdxDf[&#39;TileId&#39;].sort_values().to_list()</span>

    <span class="c1"># for constant FSP DOF</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span> <span class="c1"># constant stage for all the FSPs</span>
        <span class="c1"># find which tiles need to be mapped</span>
        <span class="c1"># select those tiles whose FSP&#39;s DOF &gt; MinDtf</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspIdxDf</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">fspDof</span><span class="p">)</span><span class="o">&gt;</span><span class="n">fspIdxDf</span><span class="p">[</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">]]</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># find the tiles need to be mapped</span>
        <span class="c1"># fspTiles = fspTiles[&#39;TileId&#39;].unique()</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># for a dataframe of FSPs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspDof</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># find which tiles need to be mapped</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fspIdxDf</span><span class="p">,</span> <span class="n">fspDof</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FspId&#39;</span><span class="p">])</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># select those where DOF &gt; minDtf</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;Dof&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;MinDtf&#39;</span><span class="p">]]</span>
        <span class="c1"># print(fspTiles)</span>
        <span class="c1"># find the tiles need to be mapped</span>
        <span class="c1"># fspTiles = fspTiles[&#39;TileId&#39;].unique()</span>
        <span class="n">fspTiles</span> <span class="o">=</span> <span class="n">fspTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported fspDof type </span><span class="si">{</span><span class="n">fspDof</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># tiles selected based on the FSPs</span>
    <span class="c1"># print(&#39;Tiles selected based on FSPs: &#39;, fspTiles)</span>

    <span class="c1"># further limit the tiles to those that interset with the AOI extent</span>
    <span class="k">if</span> <span class="n">aoiExtent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tiles</span> <span class="o">=</span> <span class="n">fspTiles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># select the tiles intersecting AOI extent based on the FPPs&#39; extent of the tile</span>
        <span class="n">aoiMinX</span><span class="p">,</span><span class="n">aoiMaxX</span><span class="p">,</span><span class="n">aoiMinY</span><span class="p">,</span><span class="n">aoiMaxY</span> <span class="o">=</span> <span class="n">aoiExtent</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="o">~</span><span class="p">((</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;FppMinX&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">aoiMaxX</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;FppMaxX&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">aoiMinX</span><span class="p">))]</span> <span class="c1"># rectangles are NOT on left or right of each other</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">aoiTiles</span><span class="p">[</span><span class="o">~</span><span class="p">((</span><span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;FppMinY&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">aoiMaxY</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;FppMaxY&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">aoiMinY</span><span class="p">))]</span> <span class="c1"># rectangles are NOT on top or bottom of each other</span>
        <span class="n">aoiTiles</span> <span class="o">=</span> <span class="n">aoiTiles</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiles selected based on AOI extent: &#39;</span><span class="p">,</span> <span class="n">aoiTiles</span><span class="p">)</span>
        <span class="c1"># intersect the lists</span>
        <span class="n">tiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fspTiles</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">aoiTiles</span><span class="p">))</span>

    <span class="c1"># tiles selected</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># print(&#39;No tile needs to be mapped!&#39;)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get each tile&#39;s fppExtent</span>
        <span class="n">fppExtents</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
            <span class="n">fppExtent</span> <span class="o">=</span> <span class="n">tileIdxDf</span><span class="p">[</span><span class="n">tileIdxDf</span><span class="p">[</span><span class="s1">&#39;TileId&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">tid</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,[</span><span class="s1">&#39;FppMinX&#39;</span><span class="p">,</span><span class="s1">&#39;FppMaxX&#39;</span><span class="p">,</span><span class="s1">&#39;FppMinY&#39;</span><span class="p">,</span><span class="s1">&#39;FppMaxY&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">fppExtents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fppExtent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tiles</span><span class="p">,</span><span class="n">fppExtents</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-08-23T21:02:34+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-08-23</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-08-16T20:54:01+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-08-16</span>
  </span>

    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 - 2024 Xingong Li
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.tracking", "navigation.top", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="../js/timeago.min.js"></script>
      
        <script src="../js/timeago_mkdocs_material.js"></script>
      
    
  </body>
</html>