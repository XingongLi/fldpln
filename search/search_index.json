{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to fldpln","text":"<p>Flood inundation modeling and mapping using the FLDPLN model</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://xingongli.github.io/fldpln</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/xingongli/fldpln/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>fldpln could always use more documentation, whether as part of the official fldpln docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/xingongli/fldpln/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up fldpln for local development.</p> <ol> <li> <p>Fork the fldpln repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/fldpln.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv fldpln\n$ cd fldpln/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 fldpln tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/xingongli/fldpln/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"fldpln/","title":"fldpln module","text":"<p>Main module.</p>"},{"location":"gauge/","title":"gauge module","text":"<p>Module for handling gauge data for flood mapping</p>"},{"location":"gauge/#fldpln.gauge.GetUsgsGauges","title":"<code>GetUsgsGauges(geobox, epsg=32614)</code>","text":"<p>Get USGS gauges within a geographic box and project them to a projected coordinate system.</p> Source code in <code>fldpln/gauge.py</code> <pre><code>def GetUsgsGauges(geobox,epsg=32614):\n    \"\"\" Get USGS gauges within a geographic box and project them to a projected coordinate system.\n        Parameters:\n            geobox--a geographic box of (minX,minY,maxX,maxY)\n            epsg--spatial coordinate system, default to UTM14 (32614) for Kansas\n        Returns: a GeoDataFrame of USGS gauges within the box\n    \"\"\"\n\n    # USGS site/gauge table fields:\n    #  agency_cd       -- Agency\n    #  site_no         -- Site identification number\n    #  station_nm      -- Site name\n    #  site_tp_cd      -- Site type\n    #  dec_lat_va      -- Decimal latitude\n    #  dec_long_va     -- Decimal longitude\n    #  coord_acy_cd    -- Latitude-longitude accuracy\n    #  dec_coord_datum_cd -- Decimal Latitude-longitude datum\n    #  alt_va          -- Altitude of gauge/land surface\n    #  alt_acy_va      -- Altitude accuracy\n    #  alt_datum_cd    -- Altitude datum\n    #  huc_cd          -- Hydrologic unit code\n    #\n    # # read in USGS gauges from Excel file which is manually generated from USGS gauge web site\n    # # See Chapter 5 in book Flood Mapping in Kansas.\n    # # This can be automated too!\n    # gaugeExcelFile = 'usgs_gauges_ks_nearby.xlsx'\n    # sheetName = 'usgs_gauges_ks_nearby'\n    # gdf = pd.read_excel(gaugeExcelFile, sheet_name=sheetName,dtype={'site_no':str,'huc_cd':str})\n    # # print('USGS gauges from web:',gdf)\n\n    # USGS Site Web Service\n    usgsSiteServiceUrl = 'http://waterservices.usgs.gov/nwis/site'\n\n    # prepare a query URL to retrieve active lake and stream USGS gauges with instantaneous values\n    # usgsSiteServiceUrl = 'http://waterservices.usgs.gov/nwis/site/?format=rdb,1.0&amp;bBox=-99.610000,36.810000,-94.200000,40.250000&amp;siteType=LK,ST&amp;siteStatus=active&amp;hasDataTypeCd=iv'\n    # parameters\n    bBox = ','.join([str(c) for c in geobox])\n    params = {'format':'rdb', 'bBox':bBox, 'siteType': 'LK,ST', 'siteStatus':'active', 'hasDataTypeCd': 'iv'}\n\n    # Send the request with the get method\n    response = requests.get(usgsSiteServiceUrl, params=params, verify=False)\n    print(response.request.url)\n\n    # turn content into list of lines\n    contentLst = response.text.split('\\n')\n\n    # find the number of lines of the header in the RDB file\n    numOfHeaderLn = 0\n    for ln in contentLst:\n        if ln[0] == '#':\n            numOfHeaderLn += 1\n        else:\n            break\n\n    # get field names\n    fieldNames = contentLst[numOfHeaderLn].split('\\t')\n    # print(fieldNames)\n\n    # turn each line into a list\n    gLst = [row.split('\\t') for row in contentLst[numOfHeaderLn+2:-1]]\n    # convert lat, longitude, and datum elevation to floats\n    for g in gLst:\n        g[4] = float(g[4])\n        g[5] = float(g[5])\n        if g[8] != '':\n            g[8] = float(g[8])\n        else:\n            g[8] = None\n        if g[9] != '':\n            g[9] = float(g[9])\n        else:\n            g[9] = None\n\n    # create a df from the list\n    gdf = pd.DataFrame(gLst, columns=fieldNames)\n\n    # turn pd into gpd using gauge's latitude and longitude coordinates\n    ggdf = gpd.GeoDataFrame(gdf, geometry=gpd.points_from_xy(gdf.dec_long_va, gdf.dec_lat_va))\n\n    # Project gauge location \n    # define gauge CRS, i.e., GCS on NAD83, assuming all USGS gauges are based on NAD83\n    ggdf = ggdf.set_crs(epsg=4326)\n    # project ggdf to library coordinate system, i.e., UTM 14N\n    ggdf = ggdf.to_crs(epsg=epsg)\n    # save the projected shapefile\n    # ggdf.to_file(shpFullName)\n\n    # add gauge's coordinates as fields\n    ggdf['x'] = ggdf['geometry'].x\n    ggdf['y'] = ggdf['geometry'].y\n\n    # USGS gauges in UTM 14N\n    gdf = ggdf.drop(columns=['geometry'])\n    # print('Gauges with UTM 14N coordinates:',gdf)\n    # print(f'Total gauges: {len(gdf)}')\n\n    return gdf\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install fldpln, run this command in your terminal:</p> <pre><code>pip install fldpln\n</code></pre> <p>This is the preferred method to install fldpln, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install fldpln from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/xingongli/fldpln\n</code></pre>"},{"location":"mapping/","title":"mapping module","text":"<p>Module for mapping tile-based library .</p>"},{"location":"mapping/#fldpln.mapping.CreateFolders","title":"<code>CreateFolders(outFolder, scratchFolderName='scratch', outMapFolderName='maps', removeExist=True)</code>","text":"<p>Create folders for storing temporary files and output maps</p> <p>Parameters:</p> Name Type Description Default <code>outFolder</code> <p>str -- output folder</p> required <code>scratchFolderName</code> <p>str -- name of the folder for storing temporary files</p> <code>'scratch'</code> <code>outMapFolderName</code> <p>str -- name of the folder for storing output maps</p> <code>'maps'</code> <code>removeExist</code> <p>bool -- whether to remove existing folders</p> <code>True</code> Source code in <code>fldpln/mapping.py</code> <pre><code>def CreateFolders(outFolder,scratchFolderName='scratch',outMapFolderName='maps',removeExist=True):\n    \"\"\" Create folders for storing temporary files and output maps\n        Parameters:\n            outFolder: str -- output folder\n            scratchFolderName: str -- name of the folder for storing temporary files\n            outMapFolderName: str -- name of the folder for storing output maps\n            removeExist: bool -- whether to remove existing folders\n        Returns: folder names for storing output maps and temporary files\n    \"\"\"\n    # create output folder if it doesn't exist\n    os.makedirs(outFolder, exist_ok=True)\n\n    # scratch folder\n    scratchFolder = os.path.join(outFolder, scratchFolderName)\n    # map output folder\n    outMapFolder = os.path.join(outFolder, outMapFolderName)\n\n    # Create the folders for storing temp and output files\n    if removeExist:\n        if os.path.isdir(scratchFolder): shutil.rmtree(scratchFolder)\n        if os.path.isdir(outMapFolder): shutil.rmtree(outMapFolder)\n\n    os.makedirs(scratchFolder, exist_ok=True)\n    os.makedirs(outMapFolder, exist_ok=True)\n\n    return outMapFolder,scratchFolder\n</code></pre>"},{"location":"tile/","title":"tile module","text":"<p>Module to re-organize FLDPLN segment-based library into tile-based library for fast mapping</p>"},{"location":"tile/#fldpln.tile.TileLibrary","title":"<code>TileLibrary(segLibFolder, cellSize, tiledLibFolder, tileSize, fileFormat)</code>","text":"<p>Tile a library. Turn segment-based FSP-FPP relations to tile-based</p> <p>Parameters:</p> Name Type Description Default <code>segLibFolder</code> <p>folder containing the segment-based library</p> required <code>cellSize</code> <p>cell size in meters</p> required <code>tiledLibFolder</code> <p>folder for the tiled library</p> required <code>tileSize</code> <p>number of cells in a tile</p> required <code>fileFormat</code> <p>'snappy' or 'mat'. 'snappy' format needs to install the 'fastparquet' python package</p> required Source code in <code>fldpln/tile.py</code> <pre><code>def TileLibrary(segLibFolder,cellSize,tiledLibFolder,tileSize,fileFormat):\n    \"\"\" Tile a library. Turn segment-based FSP-FPP relations to tile-based\n        Parameters:\n            segLibFolder: folder containing the segment-based library\n            cellSize: cell size in meters\n            tiledLibFolder: folder for the tiled library\n            tileSize: number of cells in a tile\n            fileFormat: 'snappy' or 'mat'. 'snappy' format needs to install the 'fastparquet' python package\n        Return: metadata of the tiled library\n    \"\"\"\n# This function uses the fsp_info.csv file (under tiledLibFolder) to get FSP IDs\n# fileFormat: 'snappy' or 'mat'. 'snappy' format needs to install the 'fastparquet' python package\n# tileSize changed to the number of cells on May 27, 2024 to avoid partial cells within a tile and also works for GCS system\n\n    # # create the tiledLibFolder folder for all tiled libraries if it doesn't exist\n    # os.makedirs(tiledLibFolder,exist_ok=True)\n\n    # create a folder for the tiled library\n    os.makedirs(tiledLibFolder,exist_ok=True)\n\n    # \n    # copy FSP and segment info CSV files to tiled library folder\n    # \n    shutil.copyfile(os.path.join(segLibFolder, fspInfoFileName), os.path.join(tiledLibFolder, fspInfoFileName))\n    shutil.copyfile(os.path.join(segLibFolder, segInfoFileName), os.path.join(tiledLibFolder, segInfoFileName))\n\n    #\n    # save tile size, cell size and spatial reference in a metadata file \n    #\n    # read in spatial reference for the library\n    srFile = os.path.join(segLibFolder,prjFileName)\n    with open(srFile, 'r') as srf:\n        srText = srf.read()\n    metaData = {'TileSize': tileSize, 'CellSize': cellSize, 'SpatialReference': srText}\n    # save metedata\n    with open(os.path.join(tiledLibFolder, metaDataFileName), 'w') as jf:\n        json.dump(metaData,jf)\n\n    #\n    # calculate library and segment extents\n    libExt, segExts = CalculateLibraryExtent(segLibFolder,cellSize)\n    minX,maxX,minY,maxY = libExt\n\n    # Calculate tile boundaries\n    tb = CalculateTileBoundary(minX,maxX,minY,maxY,tileSize*cellSize,tileSize*cellSize)\n    print('Number of (possible) tiles:', len(tb))\n    print('Tile extents:\\n', tb, '\\n')\n\n    #\n    # Create tiles\n    #\n    print('Build tiles (tiling FSP-FPP relations) ...')\n    hcs = cellSize/2\n    # read in FSP ID and coordinates\n    # need to set float_precision='round_trip' to prevent rounding while reading the text file! float_precision='high' DOESN'T work.\n    # For Verdigris 10-m library, FSP ID of 22246, its FspX of -1003.7918248322967 in fsp_info.csv was read into memory as -1003.7918248322968 without using float_precision='round_trip'\n    fspIds = pd.read_csv(os.path.join(segLibFolder,fspInfoFileName),float_precision='round_trip',index_col=False)[['FspId','FspX','FspY']]\n\n    # initialize the index DFs and tile ID\n    fspIdxDf = pd.DataFrame(columns=fspIdxColumnNames)\n    tileIdxDf = pd.DataFrame(columns=tileIdxColumnNames)\n    tileId = 1\n    for t in tb:\n        print('Processing tile: ', tileId)\n\n        # tile boundary, not the cell center boundary!\n        tminX, tmaxX,tminY, tmaxY = t\n        print('Tile extent (minX, maxX, minY, maxY) :',(tminX, tmaxX,tminY, tmaxY))\n\n        # find the segments that intersect the tile rectangle\n        segs = segExts[~((segExts['MinX']&gt;tmaxX) | (segExts['MaxX']&lt;tminX))] # rectangles are NOT on left or right of each other\n        segs = segs[~((segs['MinY']&gt;tmaxY) | (segs['MaxY']&lt;tminY))] # rectangles are NOT on top or bottom of each other\n        segs = segs['FileName'].to_list()\n        print('Number of segments interseting with the tile: ', len(segs))\n\n        # find the FPP-FSP relations in the tile from all the intersecting segments\n        # Initialize the df\n        tdf = pd.DataFrame()\n        for mf in segs: #segMatFileFullNames:\n            # read mat file\n            matVar = ReadMatFile(mf,matRelVarName)\n            # converting array to a dataframe\n            sdf = pd.DataFrame(matVar, columns=matRelColumnNames)\n\n            # rename columns to better names\n            betterColumnNames = [\"FspX\", \"FspY\", \"FppX\", \"FppY\", \"Dtf\", \"FilledDepth\"]\n            d=dict(zip(matRelColumnNames,betterColumnNames))\n            sdf.rename(columns=d,inplace=True) # inplace changing column name\n\n            # Code used to find out which segment file (e.g., SLIE_segment40.mat) in library 'midkan\" has problem \n            # where column \u201cDTF + fill depth\u201d is LESS than the \"DTF\" column\n            # t  =  sdf['FilledDepth'] - sdf['Dtf']\n            # t  =  t &lt; -0.1\n            # if t.any():\n            #     print('Segment: ', mf)\n            #     print(f'Found negative depression in {mf}!')\n\n            # select the FPPs within the tile\n            sdf = sdf[(sdf['FppX']&gt;=tminX) &amp; (sdf['FppX']&lt;=tmaxX) &amp; (sdf['FppY']&gt;=tminY) &amp; (sdf['FppY']&lt;=tmaxY)].copy() # tell pandas we want a copy to avoid \"SettingWithCopyWarning\" in line 86 when there is only one segment mat file read\n            # print('Segment:', segId, 'Number of FSP-FPP relations:', len(sdf))\n            if tdf.empty:\n                tdf = sdf\n            else:\n                # tdf = tdf.append(sdf)\n                tdf = pd.concat([tdf, sdf])\n        print('Total number of FSP-FPP relations in the tile:', len(tdf))\n\n        # save the FSP-FPP relations and update the index dfs\n        if (not (tdf.empty)) and (len(tdf) != 0): # there are some FPPs in the tile\n            # #calculate FilledDepth\n            # tdf['FilledDepth'] = tdf['FilledDepth']-tdf['Dtf'] # This is NOT necessary as FLDPLN model output changed to save \"sink fill depth\" in v8. Modified by Xingong on 7/1/24\n\n            # Calculate FSP center extent for the tile\n            fspMinX = tdf['FspX'].min()\n            fspMaxX = tdf['FspX'].max()\n            fspMinY = tdf['FspY'].min()\n            fspMaxY = tdf['FspY'].max()\n\n            # Calculate FPP center extent within the tile\n            fppMinX = tdf['FppX'].min()\n            fppMaxX = tdf['FppX'].max()\n            fppMinY = tdf['FppY'].min()\n            fppMaxY = tdf['FppY'].max()\n\n            # turn FPP coordinates into row and column within the tile\n            # Note that the row and column start at (fppMinX, fppMaxY)!\n            tdf['FppX'] = ((tdf.FppX-fppMinX)/cellSize).round()\n            tdf['FppY'] = ((fppMaxY-tdf.FppY)/cellSize).round()\n            # tdf['FppIdx'] = tdf.FppX * tRows + tdf.FppY\n\n            # rename ['FppX','FppY'] to ['Col','Row']\n            tdf.rename(columns={'FppX':'FppCol','FppY':'FppRow'},inplace=True)\n\n            # merge relations with FSP IDs\n            tdf = tdf.merge(fspIds,how='left',on=['FspX','FspY'])\n\n            # # check FSP IDs\n            # if tdf.isnull().values.any():\n            #     print('There are NAN in the dataframe!')\n\n            # remove FspX &amp; FspY\n            tdf.drop(['FspX','FspY'],axis=1,inplace=True)\n\n            # reorder columns\n            tdf = tdf[relColumnNames]\n\n            # set datatypes for the columns\n            tdf=tdf.astype(dtype={\"FspId\":np.int32, \"FppCol\":np.int32, \"FppRow\":np.int32, \"Dtf\":np.float32, \"FilledDepth\":np.float32},copy=False)\n            # convert float64 to float32 before saving and create index on FspX and FspY for speed up merge during mapping\n            # tdf.astype(np.float32,copy=False).set_index(keys=['FspX','FspY'],inplace=True)\n\n            # save the relations in the tile in a file\n            print('Saving FSP-FPP relations in a file...')\n            if fileFormat == 'snappy':\n                # filePathName = os.path.join(segLibFolder, tileFileMainName+'_'+str(tileId)+'.gzip') # for gzip format\n                filePathName = os.path.join(tiledLibFolder, tileFileMainName+'_'+str(tileId)+'.snz') # for snappy format\n\n                # save to parquet file. Can only save one DataFrame!\n                # tdf.to_parquet(filePathName,engine='fastparquet',compression='gzip',index=False) # gzip\n                tdf.to_parquet(filePathName,engine='fastparquet',compression='snappy',index=False) # snappy fast processing\n                # tdf.to_parquet(filePathName,engine='fastparquet',compression='snappy',index=True) # snappy fast processing\n            elif fileFormat == 'mat':\n                # separate columns by datatypes (int32 and float32)\n                fspFppsArray = tdf[relColumnNames[0:3]].to_numpy(dtype=np.int32)\n                dtfFilledDepthArray = tdf[relColumnNames[-2::]].to_numpy(dtype=np.float32)\n                # Save to compressed .mat file\n                dfDic = {'FspFpps': fspFppsArray,'DtfFilledDepth': dtfFilledDepthArray}\n                # Tile cannot be too large which may cause failure in writing into .mat file. See https://github.com/scipy/scipy/issues/12465\n                filePathName = os.path.join(tiledLibFolder, tileFileMainName+'_'+str(tileId)+'.mat')\n                sio.savemat(filePathName, dfDic, do_compression=True) \n            else:\n                print('Unsupported file format!')\n                return\n\n            # calculate the min and max DTF for each FSPs in the tile\n            fspDf = tdf.groupby(['FspId'], as_index=False).agg(MinDtf = ('Dtf', min),MaxDtf = ('Dtf', max))\n            print('Number of unique FSPs in the tile:', len(fspDf))\n            # print(fspDf)\n\n            # add tile ID to fsp-tile index\n            fspDf['TileId'] = tileId\n            # reorder columns\n            fspDf = fspDf[fspIdxColumnNames]\n            # append to the index table\n            # fspIdxDf = fspIdxDf.append(fspDf,ignore_index=True)\n            fspIdxDf = pd.concat([fspIdxDf, fspDf], ignore_index=True)\n            # print('Fsp-Tile index for the tile:')\n            # print(fspIdxDf)\n\n            # Calculate FSP &amp; FPP external extents for saving in the tile-index file\n            fspMinX,fspMaxX,fspMinY,fspMaxY = fspMinX-hcs,fspMaxX+hcs,fspMinY-hcs,fspMaxY+hcs\n            fppMinX,fppMaxX,fppMinY,fppMaxY = fppMinX-hcs,fppMaxX+hcs,fppMinY-hcs,fppMaxY+hcs\n            print('Tile FSP extent (fspMinX,fspMaxX,fspMinY,fspMaxY): ', (fspMinX,fspMaxX,fspMinY,fspMaxY))\n            print('Tile FPP extent (fppMinX,fppMaxX,fppMinY,fppMaxY): ', (fppMinX,fppMaxX,fppMinY,fppMaxY))\n\n            # Calculate the min &amp; max DTF within the tile\n            minTileDtf = fspDf['MinDtf'].min()\n            maxTileDtf = fspDf['MaxDtf'].max()\n\n            # calculate number of relations and number of FPPs in the tile\n            numOfRels = len(tdf)\n            numOfFpps = len(tdf[['FppCol','FppRow']].drop_duplicates()) # groupby for fast?\n\n            # add tile ID and additional tile-related info to the tile index file\n            tileIdx = pd.DataFrame([[tileId,tminX,tmaxX,tminY,tmaxY,fppMinX,fppMaxX,fppMinY,fppMaxY,fspMinX,fspMaxX,fspMinY,fspMaxY,minTileDtf,maxTileDtf,numOfRels,numOfFpps]],columns=tileIdxColumnNames)\n            # append to the index table\n            # tileIdxDf = tileIdxDf.append(tileIdx,ignore_index=True)\n            tileIdxDf = pd.concat([tileIdxDf, tileIdx],ignore_index=True)\n            # print('Tile index for the tile:')\n            # print(tileIdxDf)\n\n            # move to the next tile\n            tileId +=1\n\n    # Save the index as a file\n    # print('Number of items in the fsp-tile index:', len(fspIdxDf))\n    # print('fsp-tile Index table:\\n',fspIdxDf)\n    # save index to a csv file\n    print('Save fsp-tile index as a CSV file ...')\n    fspIdxDf.to_csv(os.path.join(tiledLibFolder, tileFileMainName+'_fsp_index.csv'),index=False)\n\n    # print('Number of items in the tile-extent index:', len(tileIdxDf))\n    # print('Tile index table:\\n',tileIdxDf)\n    # save index to a csv file\n    print('Save tile index as a CSV file ...')\n    tileIdxDf.to_csv(os.path.join(tiledLibFolder, tileFileMainName+'_tile_index.csv'),index=False)\n\n    return metaData\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use fldpln in a project:</p> <pre><code>import fldpln\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}